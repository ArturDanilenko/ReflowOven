0000              1   ; ISR_example_DE1SoC.asm:
0000              2   ; a) Increments/decrements a BCD variable every half second using
0000              3   ;    an ISR for timer 2.  Uses SW0 to decide.  Also 'blinks' LEDR0 every
0000              4   ;    half a second.
0000              5   ; b) Generates a 2kHz square wave at pin P1.0 using an ISR for timer 0.
0000              6   ; c) In the 'main' loop it displays the variable incremented/decremented
0000              7   ;    using the ISR for timer 2 on the LCD and the 7-segment displays.
0000              8   ;    Also resets it to zero if the KEY1 pushbutton  is pressed.
0000              9   ; d) Controls the LCD using general purpose pins P0.0 to P0.6.  Pins P0.0
0000             10   ;    to P0.6 are configured as outputs.
0000             11   ;
                 13   $LIST
0000             15   
0000             16   CLK           EQU 33333333 ; Microcontroller system crystal frequency in Hz
0000             17   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             18   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is 12 unlike the AT89LP51RC2 where is 1.
0000             19   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             20   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             21   
0000             22   SOUND_OUT     equ P1.0
0000             23   UPDOWN        equ SWA.0
0000             24   
0000             25   ; Reset vector
0000             26   org 0x0000
0000 02018B      27       ljmp main
0003             28   
0003             29   ; External interrupt 0 vector (not used in this code)
0003             30   org 0x0003
0003 32          31            reti
0004             32   
0004             33   ; Timer/Counter 0 overflow interrupt vector
000B             34   org 0x000B
000B 02011E      35            ljmp Timer0_ISR
000E             36   
000E             37   ; External interrupt 1 vector (not used in this code)
0013             38   org 0x0013
0013 32          39            reti
0014             40   
0014             41   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             42   org 0x001B
001B 32          43            reti
001C             44   
001C             45   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             46   org 0x0023 
0023 32          47            reti
0024             48            
0024             49   ; Timer/Counter 2 overflow interrupt vector
002B             50   org 0x002B
002B 020138      51            ljmp Timer2_ISR
002E             52   
002E             53   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             54   dseg at 0x30
0030             55   Count1ms:     ds 2 ; Used to determine when half second has passed
0032             56   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033             57   
0033             58   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0033             59   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             60   bseg
0000             61   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             62   
002E             63   cseg
002E             64   ; These 'equ' must match the wiring between the DE1-SoC board and the LCD!
002E             65   ; P0 is in connector JP2.  Check "CV-8052 Soft Processor in the DE1-SoC Board: Getting
002E             66   ; Started Guide" for the details.
002E             67   ELCD_RS equ P1.2
002E             68   ELCD_RW equ P1.3
002E             69   ELCD_E  equ P1.4
002E             70   ELCD_D4 equ P1.5
002E             71   ELCD_D5 equ P1.6
002E             72   ELCD_D6 equ P1.7
002E             73   ELCD_D7 equ P0.6
                 75   	$LIST
00E9             77   
00E9             78   ;                     1234567890123456    <- This helps determine the location of the counter
00E9 4243445F    79   Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
00FA 4D6F7269    80   Initial_Message1:  db 'MorituriTeSaluta', 0
     74757269
     54655361
     6C757461
     00
010B             81   
010B             82   ;---------------------------------;
010B             83   ; Routine to initialize the ISR   ;
010B             84   ; for timer 0                     ;
010B             85   ;---------------------------------;
010B             86   Timer0_Init:
010B E589        87            mov a, TMOD
010D 54F0        88            anl a, #0xf0 ; Clear the bits for timer 0
010F 4401        89            orl a, #0x01 ; Configure timer 0 as 16-timer
0111 F589        90            mov TMOD, a
0113 758CFD      91            mov TH0, #high(TIMER0_RELOAD)
0116 758A5A      92            mov TL0, #low(TIMER0_RELOAD)
0119             93            ; Enable the timer and interrupts
0119 D2A9        94       setb ET0  ; Enable timer 0 interrupt
011B D28C        95       setb TR0  ; Start timer 0
011D 22          96            ret
011E             97   
011E             98   ;---------------------------------;
011E             99   ; ISR for timer 0.  Set to execute;
011E            100   ; every 1/4096Hz to generate a    ;
011E            101   ; 2048 Hz square wave at pin P3.7 ;
011E            102   ;---------------------------------;
011E            103   Timer0_ISR:
011E            104            ;clr TF0  ; According to the data sheet this is done for us already.
011E            105   ;        mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
011E            106   ;        mov TL0, #low(TIMER0_RELOAD)
011E            107   ;        cpl SOUND_OUT ; Connect speaker to P3.7!
011E 32         108            reti
011F            109   
011F            110   ;---------------------------------;
011F            111   ; Routine to initialize the ISR   ;
011F            112   ; for timer 2                     ;
011F            113   ;---------------------------------;
011F            114   Timer2_Init:
011F 75C800     115            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0122 75CDF5     116            mov TH2, #high(TIMER2_RELOAD)
0125 75CC27     117            mov TL2, #low(TIMER2_RELOAD)
0128            118            ; Set the reload value
0128 75CBF5     119            mov RCAP2H, #high(TIMER2_RELOAD)
012B 75CA27     120            mov RCAP2L, #low(TIMER2_RELOAD)
012E            121            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
012E E4         122            clr a
012F F530       123            mov Count1ms+0, a
0131 F531       124            mov Count1ms+1, a
0133            125            ; Enable the timer and interrupts
0133 D2AD       126       setb ET2  ; Enable timer 2 interrupt
0135 D2CA       127       setb TR2  ; Enable timer 2
0137 22         128            ret
0138            129   
0138            130   ;---------------------------------;
0138            131   ; ISR for timer 2                 ;
0138            132   ;---------------------------------;
0138            133   Timer2_ISR:
0138 C2CF       134            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
013A            135   ;        cpl P1.1 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
013A            136            
013A            137            ; The two registers used in the ISR must be saved in the stack
013A C0E0       138            push acc
013C C0D0       139            push psw
013E            140            
013E            141            ; Increment the 16-bit one mili second counter
013E 0530       142            inc Count1ms+0    ; Increment the low 8-bits first
0140 E530       143            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0142 7002       144            jnz Inc_Done
0144 0531       145            inc Count1ms+1
0146            146   
0146            147   Inc_Done:
0146            148            ; Check if half second has passed
0146 E530       149            mov a, Count1ms+0
0148 B4F41E     150            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
014B E531       151            mov a, Count1ms+1
014D B40119     152            cjne a, #high(500), Timer2_ISR_done
0150            153            
0150            154            ; 500 milliseconds have passed.  Set a flag so the main program knows
0150 D200       155            setb half_seconds_flag ; Let the main program know half second had passed
0152            156            ; Toggle LEDR0 so it blinks
0152 B2E8       157            cpl LEDRA.0
0154 B28C       158            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0156            159            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0156 E4         160            clr a
0157 F530       161            mov Count1ms+0, a
0159 F531       162            mov Count1ms+1, a
015B            163            ; Increment the BCD counter
015B E532       164            mov a, BCD_counter
015D 20E804     165            jb UPDOWN, Timer2_ISR_decrement
0160 2401       166            add a, #0x01
0162 8002       167            sjmp Timer2_ISR_da
0164            168   Timer2_ISR_decrement:
0164 2499       169            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0166            170   Timer2_ISR_da:
0166 D4         171            da a ; Decimal adjust instruction.  Check datasheet for more details!
0167 F532       172            mov BCD_counter, a
0169            173            
0169            174   Timer2_ISR_done:
0169 D0D0       175            pop psw
016B D0E0       176            pop acc
016D 32         177            reti
016E            178   
016E            179   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
016E            180   T_7seg:
016E 40792430   181       DB 40H, 79H, 24H, 30H, 19H, 12H, 02H, 78H, 00H, 10H
     19120278
     0010
0178            182   
0178            183   ; Displays a BCD number in HEX1-HEX0
0178            184   Display_BCD_7_Seg:
0178            185            
0178 90016E     186            mov dptr, #T_7seg
017B            187   
017B E532       188            mov a, BCD_counter
017D C4         189            swap a
017E 540F       190            anl a, #0FH
0180 93         191            movc a, @a+dptr
0181 F592       192            mov HEX1, a
0183            193            
0183 E532       194            mov a, BCD_counter
0185 540F       195            anl a, #0FH
0187 93         196            movc a, @a+dptr
0188 F591       197            mov HEX0, a
018A            198            
018A 22         199            ret
018B            200   
018B            201   ;---------------------------------;
018B            202   ; Main program. Includes hardware ;
018B            203   ; initialization and 'forever'    ;
018B            204   ; loop.                           ;
018B            205   ;---------------------------------;
018B            206   main:
018B            207            ; Initialization
018B 75817F     208       mov SP, #0x7F
018E 12010B     209       lcall Timer0_Init
0191 12011F     210       lcall Timer2_Init
0194            211       ; We use the pins of P0 to control the LCD.  Configure as outputs.
0194 759AFF     212       mov P0MOD, #11111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
0197            213       ; We use pins P1.0 and P1.1 as outputs also.  Configure accordingly.
0197 759BFF     214       mov P1MOD, #11111111b ; P1.0 and P1.0 are outputs
019A            215       ; Turn off all the LEDs
019A 75E800     216       mov LEDRA, #0 ; LEDRA is bit addressable
019D 759500     217       mov LEDRB, #0 ; LEDRB is NOT bit addresable
01A0 D2AF       218       setb EA   ; Enable Global interrupts
01A2 12008A     219       lcall ELCD_4BIT ; Configure LCD in four bit mode
01A5            220       ; For convenience a few handy macros are included in 'LCD_4bit_DE1SoC.inc':
01A5 C0E0       221            push acc
01A7 7401       221            mov a, #1
01A9 14         221            dec a
01AA 1200CC     221            lcall ?Set_Cursor_1 ; Select column and row
01AD D0E0       221            pop acc
01AF C083       222            push dph
01B1 C082       222            push dpl
01B3 C0E0       222            push acc
01B5 9000E9     222            mov dptr, #Initial_Message
01B8 1200BF     222            lcall ?Send_Constant_String
01BB D0E0       222            pop acc
01BD D082       222            pop dpl
01BF D083       222            pop dph
01C1 D200       223       setb half_seconds_flag
01C3 753200     224            mov BCD_counter, #0x00 ; Initialize counter to zero
01C6            225            
01C6            226            ; After initialization the program stays in this 'forever' loop
01C6            227   loop:
01C6 20F91C     228            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
01C9 C002       229            push AR2
01CB 7A32       229            mov R2, #50
01CD 12003B     229            lcall ?Wait_Milli_Seconds
01D0 D002       229            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit_DE1SoC.inc'
01D2 20F910     230            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
01D5 30F9FD     231            jnb KEY.1, $            ; Wait for button release.  The '$' means: jump to same instruction.
01D8            232            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
01D8            233            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
01D8 C2CA       234            clr TR2 ; Stop timer 2
01DA E4         235            clr a
01DB F530       236            mov Count1ms+0, a
01DD F531       237            mov Count1ms+1, a
01DF            238            ; Now clear the BCD counter
01DF F532       239            mov BCD_counter, a
01E1 D2CA       240            setb TR2    ; Start timer 2
01E3 8003       241            sjmp loop_b ; Display the new value
01E5            242   loop_a:
01E5 3000DE     243            jnb half_seconds_flag, loop
01E8            244   loop_b:
01E8 C200       245       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
01EA            246     ;Send_Constant_String(#Initial_Message1)
01EA C0E0       247            push acc
01EC 740E       247            mov a, #14
01EE 14         247            dec a
01EF 1200CC     247            lcall ?Set_Cursor_1 ; Select column and row
01F2 D0E0       247            pop acc     ; the place in the LCD where we want the BCD counter value
01F4 C000       248            push ar0
01F6 A832       248            mov r0, BCD_counter
01F8 1200D3     248            lcall ?Display_BCD
01FB D000       248            pop ar0 ; This macro is also in 'LCD_4bit_DE1SoC.inc'
01FD 120178     249            lcall Display_BCD_7_Seg ; Also display the counter using the 7-segment displays.
0200 0201C6     250       ljmp loop
0203            251   END
