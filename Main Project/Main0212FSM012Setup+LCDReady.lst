0000              1   ; This program tests the LTC2308 avaliable in the newer version of the DE1-SoC board.
0000              2   ; Access to the input pins of the ADC is avalible at connector J15. Here is the top
0000              3   ; view of the connector:
0000              4   ;
0000              5   ; +--+
0000              6   ; |  | <-- Red power button
0000              7   ; +--+
0000              8   ;
0000              9   ; +-----+-----+
0000             10   ; + GND | IN7 |
0000             11   ; +-----+-----+
0000             12   ; + IN6 | IN5 |
0000             13   ; +-----+-----+
0000             14   ; + IN4 | IN3 |
0000             15   ; +-----+-----+
0000             16   ; + IN2 | IN1 |
0000             17   ; ------+-----+
0000             18   ; + IN0 | 5V  |
0000             19   ; +-----+-----+
0000             20   ;      J15
0000             21   ; 
0000             22   ; Displays the result using the 7-segment displays and also sends it via the serial port to PUTTy.
0000             23   ;
0000             24   ; (c) Jesus Calvino-Fraga 2019
0000             25   ;
                 27   $LIST
0000             29   
0000             30   ; Bits used to access the LTC2308
0000             31   LTC2308_MISO bit 0xF8 ; Read only bit
0000             32   LTC2308_MOSI bit 0xF9 ; Write only bit
0000             33   LTC2308_SCLK bit 0xFA ; Write only bit
0000             34   LTC2308_ENN  bit 0xFB ; Write only bit
0000             35   
0000             36   ;BUTTONS
0000             37   button1          equ P2.1
0000             38   button2          equ P2.2
0000             39   button3          equ P2.3
0000             40   button4          equ P2.4
0000             41   button5          equ P2.5
0000             42   ;STATES
0000             43   Select           equ 0
0000             44   RAMPTOSOAK       equ 1
0000             45   PREHEAT          equ 2
0000             46   RAMPTOPEAK       equ 3
0000             47   REFLOW           equ 4
0000             48   COOLING          equ 5
0000             49   
0000             50   CLK EQU 33333333
0000             51   BAUD EQU 57600
0000             52   TIMER_2_RELOAD EQU (65536-(CLK/(32*BAUD)))
0000             53   TIMER_0_1ms EQU (65536-(CLK/(12*1000)))
0000             54   
0000             55   ;;
0000             56   ;;
0000             57   ;; PUSH BUTTON DEFINITIONS
0000             58   ;;
0000             59   ;;
0000             60   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             61   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is 12 unlike the AT89LP51RC2 where is 1.
0000             62   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             63   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             64   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0000             65   
0000             66   
0000             67   ; Reset vector
0000             68   org 0x0000
0000 02062E      69       ljmp MainProgram
0003             70   
0003             71   ; External interrupt 0 vector (not used in this code)
0003             72   org 0x0003
0003 32          73            reti
0004             74   
0004             75   ; Timer/Counter 0 overflow interrupt vector
000B             76   org 0x000B
000B 0205A5      77            ljmp Timer0_ISR
000E             78   
000E             79   ; External interrupt 1 vector (not used in this code)
0013             80   org 0x0013
0013 32          81            reti
0014             82   
0014             83   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             84   org 0x001B
001B 32          85            reti
001C             86   
001C             87   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             88   org 0x0023 
0023 32          89            reti
0024             90            
0024             91   ; Timer/Counter 2 overflow interrupt vector
002B             92   org 0x002B
002B 0205C5      93            ljmp Timer2_ISR
002E             94            
002E             95   SOUND_OUT     equ P1.0
002E             96   UPDOWN        equ SWA.0
002E             97   
002E             98   ; Reset vector
002E             99   
002E            100   
002E            101   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            102   dseg at 0x30
0030            103   Count1ms:     ds 2 ; Used to determine when half second has passed
0032            104   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            105   Seconds:  ds 1
0034            106   Minutes: ds 1
0035            107   pwm: ds 1
0036            108   x:       ds 4
003A            109   y:       ds 4
003E            110   bcd:     ds 5
0043            111   buffer: ds 30
0061            112   vResult:         ds 2
0063            113   cTemp:   ds 2
0065            114   hTemp:   ds 3
0068            115   tTemp:   ds 3
006B            116   ;FSM Variables
006B            117   temp_soak: ds 1
006C            118   time_soak: ds 1
006D            119   temp_refl: ds 1
006E            120   time_refl: ds 1
006F            121   temp: ds 1
0070            122   timer: ds 1
0071            123   state: ds 1
0072            124   sec: ds 1
0073            125   MyHope: ds 1
0074            126   MyHope2: ds 1
0075            127   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0075            128   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            129   bseg
0000            130   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            131   mf: dbit 1
0002            132   
002E            133   cseg     
002E            134   BJTBase equ P0.0
002E            135   ELCD_RS equ P1.2
002E            136   ELCD_RW equ P1.3
002E            137   ELCD_E  equ P1.4
002E            138   ELCD_D4 equ P1.5
002E            139   ELCD_D5 equ P1.6
002E            140   ELCD_D6 equ P1.7
002E            141   ELCD_D7 equ P0.6
002E            142   
002E            143   CE_ADC   EQU P0.2
002E            144   MY_MOSI EQU P0.0
002E            145   MY_MISO EQU P2.0
002E            146   MY_SCLK EQU P0.1
002E            147   
002E            148   PWMout equ P0.3
002E            149   
                622   $LIST
                152   $LIST
0541            154   
0541 0D0A4C54   155   InitialString: db '\r\nLTC2308 test program\r\n', 0
     43323330
     38207465
     73742070
     726F6772
     616D0D0A
     00
055A 48656C6F   156   MyString: db 'Helo213qwq', 0
     32313371
     777100
0565            157   Hello_World: ;indent to separate numbers in the putty
0565 0D0A00     158       DB  '\r','\n', 0
0568            159   
0568            160   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0568            161   T_7seg:
0568 40792430   162       DB 40H, 79H, 24H, 30H, 19H, 12H, 02H, 78H, 00H, 10H
     19120278
     0010
0572            163   
0572            164   ; Display the 4-digit bcd stored in [R3,R2] using the 7-segment displays
0572            165   
0572            166   
0572            167   ; Send a 4-digit BCD number stored in [R3,R2] to the serial port         
0572            168   
0572            169            
0572            170   ; Wait 1 millisecond using Timer 0
0572            171   Wait1ms:
0572 C28C       172            clr     TR0
0574 74F0       173            mov     a,#0xF0
0576 5589       174            anl     a,TMOD
0578 4401       175            orl     a,#0x01
057A F589       176            mov     TMOD,a
057C 758CF5     177            mov     TH0, #high(TIMER_0_1ms)
057F 758A27     178            mov     TL0, #low(TIMER_0_1ms)
0582 C28D       179            clr     TF0
0584 D28C       180            setb TR0
0586 308DFD     181            jnb     TF0,$
0589 C28C       182            clr     TR0
058B 22         183            ret
058C            184            
058C            185   ; Wait R2 milliseconds
058C            186   MyDelay:
058C 120572     187            lcall Wait1ms
058F DAFB       188       djnz R2, MyDelay
0591 22         189            ret
0592            190            
0592            191   Timer0_Init:
0592 E589       192            mov a, TMOD
0594 54F0       193            anl a, #0xf0 ; Clear the bits for timer 0
0596 4401       194            orl a, #0x01 ; Configure timer 0 as 16-timer
0598 F589       195            mov TMOD, a
059A 758CFD     196            mov TH0, #high(TIMER0_RELOAD)
059D 758A5A     197            mov TL0, #low(TIMER0_RELOAD)
05A0            198            ; Enable the timer and interrupts
05A0 D2A9       199       setb ET0  ; Enable timer 0 interrupt
05A2 D28C       200       setb TR0  ; Start timer 0
05A4 22         201            ret
05A5            202   
05A5            203   ;---------------------------------;
05A5            204   ; ISR for timer 0.  Set to execute;
05A5            205   ; every 1/4096Hz to generate a    ;
05A5            206   ; 2048 Hz square wave at pin P3.7 ;
05A5            207   ;---------------------------------;
05A5            208   Timer0_ISR:
05A5            209   ;        clr TF0  ; According to the data sheet this is done for us already.
05A5 758CFD     210            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
05A8 758A5A     211            mov TL0, #low(TIMER0_RELOAD)
05AB            212   ;        cpl SOUND_OUT ; Connect speaker to P3.7!
05AB 32         213            reti
05AC            214   
05AC            215   ;---------------------------------;
05AC            216   ; Routine to initialize the ISR   ;
05AC            217   ; for timer 2                     ;
05AC            218   ;---------------------------------;
05AC            219   Timer2_Init:
05AC 75C800     220            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
05AF 75CDF5     221            mov TH2, #high(TIMER2_RELOAD)
05B2 75CC27     222            mov TL2, #low(TIMER2_RELOAD)
05B5            223            ; Set the reload value
05B5 75CBF5     224            mov RCAP2H, #high(TIMER2_RELOAD)
05B8 75CA27     225            mov RCAP2L, #low(TIMER2_RELOAD)
05BB            226            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
05BB E4         227            clr a
05BC F530       228            mov Count1ms+0, a
05BE F531       229            mov Count1ms+1, a
05C0            230            ; Enable the timer and interrupts
05C0 D2AD       231       setb ET2  ; Enable timer 2 interrupt
05C2 D2CA       232       setb TR2  ; Enable timer 2
05C4 22         233            ret
05C5            234   
05C5            235   ;---------------------------------;
05C5            236   ; ISR for timer 2                 ;
05C5            237   ;---------------------------------;
05C5            238   Timer2_ISR:
05C5 C2CF       239            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
05C7            240   ;        cpl P1.1 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
05C7            241            
05C7            242            ; The two registers used in the ISR must be saved in the stack
05C7 C0E0       243            push acc
05C9 C0D0       244            push psw
05CB            245            
05CB            246            ; Increment the 16-bit one mili second counter
05CB 0530       247            inc Count1ms+0    ; Increment the low 8-bits first
05CD E530       248            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05CF 7002       249            jnz Inc_Done
05D1 0531       250            inc Count1ms+1
05D3            251   
05D3            252   Inc_Done:;===========================================ISR MAIN=============================================
05D3            253            ; Check if half second has passed
05D3 E530       254            mov a, Count1ms+0
05D5 B4F451     255            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
05D8 E531       256            mov a, Count1ms+1
05DA B4014C     257            cjne a, #high(500), Timer2_ISR_done
05DD            258            
05DD            259            ; 500 milliseconds have passed.  Set a flag so the main program knows
05DD D200       260            setb half_seconds_flag ; Let the main program know half second had passed
05DF            261            ; Toggle LEDR0 so it blinks
05DF            262            ;=====================Timer 0 controls============================================
05DF            263            ;cpl LEDRA.0
05DF B28C       264            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
05E1            265            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
05E1            266            ;==================================================================================================
05E1 E4         267            clr a
05E2            268            ;=====================Display=============================================
05E2            269   ;        mov x+0, Temp_soak+0
05E2            270   ;        mov x+1, #0
05E2            271   ;        mov x+2, #0
05E2            272   ;        mov x+3, #0
05E2            273   ;
05E2            274   ;        Load_Y(1)
05E2            275   ;        lcall mul32
05E2            276   ;        lcall hex2bcd
05E2            277   
05E2            278   ;        Send_BCD(bcd+1)
05E2            279            
05E2 C0E0       280            push acc
05E4 7401       280            mov a, #1
05E6 14         280            dec a
05E7 1201D4     280            lcall ?Set_Cursor_2 ; Select column and row
05EA D0E0       280            pop acc
05EC C000       281            push ar0
05EE A834       281            mov r0, minutes
05F0 1201DB     281            lcall ?Display_BCD
05F3 D000       281            pop ar0
05F5 C0E0       282            push acc
05F7 7404       282            mov a, #4
05F9 14         282            dec a
05FA 1201D4     282            lcall ?Set_Cursor_2 ; Select column and row
05FD D0E0       282            pop acc
05FF            283   ;        Send_BCD(bcd)
05FF C000       284            push ar0
0601 A833       284            mov r0, seconds
0603 1201DB     284            lcall ?Display_BCD
0606 D000       284            pop ar0
0608            285   ;        mov DPTR, #Hello_World
0608            286   ;        lcall SendString
0608            287   ;==============================================================================================
0608 F530       288            mov Count1ms+0, a
060A F531       289            mov Count1ms+1, a
060C            290            ; Increment the BCD counter
060C            291            
060C E573       292            mov a, MyHope
060E 2401       293            add a, #1
0610 F573       294            mov MyHope, a
0612            295   
0612            296            
0612 1207A9     297            lcall ReadTemperature
0615 E533       298            mov a, Seconds
0617            299   ;        jb UPDOWN, Timer2_ISR_decrement
0617 2401       300            add a, #0x01
0619            301            ;sjmp Timer2_ISR_da
0619            302   ;Timer2_ISR_decrement:;=====================ISR DECREMENT=============================================
0619            303   ;        add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.    
0619            304            
0619            305            
0619            306   Timer2_ISR_da:
0619 D4         307            da a ; Decimal adjust instruction.  Check datasheet for more details!   
061A F533       308            mov seconds, a
061C            309   
061C B4600A     310            cjne a, #0x60, Timer2_ISR_done ;if seconds are not 60, go to ISR_done
061F 753300     311            mov Seconds, #0x0 ;reset seconds to 0
0622 E534       312            mov a, Minutes ; set a to previous minutes
0624 2401       313            add a, #0x01 ;add one to obtain current minutes
0626 D4         314            da a ;makes formatting nice 
0627 F534       315            mov Minutes, a ;put updated minutes into the counter
0629            316   ;        sjmp Timer2_ISR_M_aadjust
0629            317            
0629            318   Timer2_ISR_done:
0629 D0D0       319            pop psw
062B D0E0       320            pop acc
062D 32         321            reti
062E            322            
062E            323   
062E            324   MainProgram:;============================MAIN===========================================================
062E 75817F     325       mov sp, #0x7f
0631 120592     326       lcall Timer0_Init
0634 1205AC     327       lcall Timer2_Init
0637 120095     328       lcall Initialize_LEDs
063A 12007E     329       lcall Initialize_Serial_Port
063D 12009C     330       lcall Initialize_ADC
0640 120592     331       lcall Timer0_Init
0643 1205AC     332       lcall Timer2_Init
0646 120229     333       lcall INIT_SPI
0649            334   ;FSM Variables  ==================
0649 E4         335            clr a
064A F56B       336            mov temp_soak, a
064C 756B1E     337       mov temp_soak, #0x1e ; Will remain in hex, 0x82 is orig value else is for debugging
064F 756C3C     338            mov time_soak, #0x3c     ;HAS TO BE IN HEX only convert to bcd for display!
0652 756D23     339            mov temp_refl, #0x23 ;230 0xdc is original, else debug
0655 756E41     340            mov time_refl, #0x41 ;65
0658            341            
0658 756F19     342            mov temp, #25
065B 757000     343            mov timer, #0x00
065E 757100     344            mov state, #0x00
0661 757200     345            mov sec, #0x00
0664 753400     346            mov minutes, #0
0667 750100     347            mov mf, #0
066A 757300     348            mov MyHope, #0
066D            349   ;========================
066D            350     ;  lcall InitSerialPort
066D 759AFF     351       mov P0MOD, #11111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
0670            352       ; We use pins P1.0 and P1.1 as outputs also.  Configure accordingly.
0670 759BFF     353       mov P1MOD, #11111111b ; P1.0 and P1.0 are outputs
0673 120194     354       lcall ELCD_4BIT
0676            355     ;  clr EX1
0676 D2AF       356       setb EA
0678            357   
0678            358   ;        Set_Cursor(1,1)
0678            359   ;        Send_Constant_String(#MyString)
0678 B2EC       360            cpl LEDRA.4
067A D200       361            setb half_seconds_flag
067C 753350     362            mov Seconds, #0x50
067F 12083F     363            lcall DisplayVariables
0682            364   forever:;======================================================FOREVER===========================================================
0682 E5E8       365            mov a, SWA ; read the channel to convert from the switches
0684 5407       366            anl a, #00000111B ; We need only the last three bits since there are only eight channels
0686 F5F0       367            mov b, a
0688 1200AC     368            lcall LTC2308_RW  ; Read the channel from the ADC
068B 120060     369            lcall hex2bcd16   ; Convert to bcd
068E            370   ;        lcall Display_BCD1 ; Display using the 7-segment displays
068E            371   ;        lcall SendNumber  ; Send to serial port
068E            372   ;        jnb BJTBase, pinpressed
068E 7AFA       373            mov R2, #250
0690            374            
0690 20F91C     375            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
0693 C002       376            push AR2
0695 7A32       376            mov R2, #50
0697 120145     376            lcall ?Wait_Milli_Seconds
069A D002       376            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit_DE1SoC.inc'
069C 20F910     377            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
069F 30F9FD     378            jnb KEY.1, $    
06A2 C2CA       379            clr TR2 ; Stop timer 2
06A4 E4         380            clr a
06A5 F530       381            mov Count1ms+0, a
06A7 F531       382            mov Count1ms+1, a
06A9            383            ; Now clear the BCD counter
06A9 F532       384            mov BCD_counter, a
06AB D2CA       385            setb TR2    ; Start timer 2
06AD 8003       386            sjmp loop_b ; Display the new value
06AF            387   loop_a:;======================================================FOREVER================================================
06AF 3000D0     388            jnb half_seconds_flag, forever
06B2            389   loop_b:;======================================================FOREVER================================================
06B2 C200       390            clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
06B4 C0E0       391            push acc
06B6 740F       391            mov a, #15
06B8 14         391            dec a
06B9 1201D4     391            lcall ?Set_Cursor_2 ; Select column and row
06BC D0E0       391            pop acc     ; the place in the LCD where we want the BCD counter value
06BE C000       392            push ar0
06C0 A871       392            mov r0, state
06C2 1201DB     392            lcall ?Display_BCD
06C5 D000       392            pop ar0
06C7            393   ;        cpl LEDRA.4
06C7            394   
06C7 E571       395       mov a, state
06C9            396    ;=======================================================STATE 0========================================
06C9            397   ResetState:
06C9 B4002B     398            cjne a, #select, RampToSoakState
06CC            399   ;Display Time Soak
06CC            400   
06CC            401            
06CC 30A122     402            jnb button1, Pathnextstate
06CF 30A20B     403            jnb button2, PathTempSoakAdjust
06D2 30A30D     404            jnb button3, PathTimeSoakAdjust
06D5 30A414     405            jnb button4, PathTempReflowAdjust
06D8 30A50C     406            jnb button5, PathTimeReflowAdjust ; TimeReflowAdjust jump
06DB 801A       407            sjmp RampToSoakState
06DD            408   PathTempSoakAdjust:
06DD 1208E6     409            lcall TempSoakAdjust
06E0 8012       410            sjmp SkipSetup1
06E2            411   PathTimeSoakAdjust:
06E2 120955     412            lcall TimeSoakAdjust
06E5 800D       413            sjmp SkipSetup1
06E7            414   PathTimeReflowAdjust: 
06E7 120A45     415            lcall TimeReflowAdjust
06EA 8008       416            sjmp SkipSetup1
06EC            417   PathTempReflowAdjust:
06EC 1209D6     418            lcall TempReflowAdjust
06EF 8003       419            sjmp SkipSetup1
06F1            420   PathNextState:
06F1 02077F     421            ljmp nextstate
06F4            422   SkipSetup1:;=====================CHANGE  OF STATES==============================================
06F4 020682     423            ljmp forever
06F7            424   
06F7            425            ;mov Seconds, #0x00
06F7            426            ;mov minutes, #0
06F7            427   RampToSoakState:         ;==============================STATE 1================================================
06F7 B40128     428            cjne a, #RampToSoak, PreHeatState
06FA 753564     429            mov pwm, #100
06FD            430     ;  mov sec, #0
06FD            431    ;=============================Checking ih current temp has reaches soak temp==========================================   
06FD 856536     432            mov x, hTemp
0700 753700     433            mov x+1, #0
0703 753800     434            mov x+2, #0
0706 753900     435            mov x+3, #0
0709            436   
0709 856B3A     437            mov y, temp_soak
070C 753B00     438            mov y+1, #0
070F 753C00     439            mov y+2, #0
0712 753D00     440            mov y+3, #0
0715 12035A     441            lcall x_lt_y
0718            442   ;====================================If its reached, move on to the next state, if not abort if 60 seconds passed=============
0718 300164     443            jnb     mf, nextstate
071B E534       444            mov a, Minutes
071D B4015C     445       cjne a, #0x01, SkipSetup
0720 807C       446       sjmp abort
0722            447   
0722            448   PreHeatState:;====================================================STATE 2===========================================
0722 B40208     449            cjne a, #PreHeat, RampToHeatState
0725 E573       450            mov a, MyHope
0727 B56C52     451            cjne a, Time_Soak, SkipSetup
072A 12077F     452            lcall nextstate
072D            453   RampToHeatState:;====================================================STATE 3===========================================
072D B40320     454            cjne a, #RampToPeak, ReflowState
0730            455   
0730 856536     456            mov x, hTemp
0733 753700     457            mov x+1, #0
0736 753800     458            mov x+2, #0
0739 753900     459            mov x+3, #0
073C            460   
073C 856D3A     461            mov y, temp_refl
073F 753B00     462            mov y+1, #0
0742 753C00     463            mov y+2, #0
0745 753D00     464            mov y+3, #0
0748 12035A     465            lcall x_lt_y
074B            466                            
074B 300131     467            jnb     mf, nextstate
074E 802C       468            sjmp SkipSetup
0750            469   ReflowState:
0750 B40408     470            cjne a, #Reflow, CoolingState
0753 E573       471            mov a, MyHope
0755 B56E24     472            cjne a, Time_Refl, SkipSetup
0758 12077F     473            lcall nextstate
075B            474   CoolingState:
075B B4051E     475            cjne a, #Cooling, SkipSetup
075E 856536     476            mov x, hTemp
0761 753700     477            mov x+1, #0
0764 753800     478            mov x+2, #0
0767 753900     479            mov x+3, #0
076A            480   
076A 753A20     481            mov y, #0x20
076D 753B00     482            mov y+1, #0
0770 753C00     483            mov y+2, #0
0773 753D00     484            mov y+3, #0
0776 12035A     485            lcall x_lt_y
0779            486                            
0779 200103     487            jb      mf, nextstate
077C            488            
077C            489   SkipSetup:;=====================CHANGE  OF STATES==============================================
077C 020682     490            ljmp forever
077F            491   nextstate: ;=====================CHANGE  OF STATES==============================================
077F C002       492            push AR2
0781 7A32       492            mov R2, #50
0783 120145     492            lcall ?Wait_Milli_Seconds
0786 D002       492            pop AR2
0788 753300     493            mov seconds, #0
078B 753400     494            mov minutes, #0
078E 757300     495            mov MyHope, #0
0791 E571       496            mov a, state
0793 2401       497            add a, #1
0795 B4060C     498            cjne a, #6, NoStateReset
0798 757100     499            mov state, #0
079B            500   ;        cpl LEDRA.7
079B            501   
079B 02077C     502            ljmp SkipSetup
079E            503   abort: ;=================================ABORT1=====================================================
079E 757100     504            mov state, #0
07A1 02077C     505            ljmp SkipSetup
07A4            506   ;====================================================PATHS==(if ljmp is outside of bounds)==============================================
07A4            507   
07A4            508   NoStateReset:;=====================STATE OVERFLOW==============================================
07A4 F571       509            mov state, a
07A6            510            ;cpl LEDRA.7
07A6 02077C     511            ljmp SkipSetup  
07A9            512   
07A9            513   ReadTemperature: 
07A9 75F000     514            mov b, #0
07AC 1201F1     514            lcall _Read_ADC_Channel
07AF C000       515            push aR0
07B1 A863       515            mov R0, cTemp
07B3 1204C2     515            lcall _volt2ctemp
07B6 D000       515            pop aR0 
07B8            516   ;        mov cTemp, bcd
07B8 75F006     517            mov b, #6
07BB 1201F1     517            lcall _Read_ADC_Channel
07BE C000       518            push aR0
07C0 A865       518            mov R0, hTemp
07C2 120509     518            lcall _volt2htemp
07C5 D000       518            pop aR0
07C7            519   ;        So In order to keep stuff in hex, Got to convert cTemp back from bcd to hex. NOT CONVERTING TO BCD IN THE FIRST PLACE DIDNOT WORK. GAVE 0
07C7 85633E     520            mov bcd+0, cTemp+0
07CA 85643F     521            mov bcd+1, cTemp+1
07CD 754000     522            mov bcd+2, #0
07D0 754100     523            mov bcd+3, #0
07D3 754200     524            mov bcd+4, #0
07D6 1202DB     525            lcall bcd2hex
07D9 853663     526            mov cTemp + 0, x + 0
07DC 853764     527            mov cTemp + 1, x + 1
07DF            528   ;======Adding cold junction temp=======================================================  
07DF E565       529            mov a, hTemp
07E1 2563       530            add a, cTemp
07E3 F565       531            mov hTemp, a
07E5            532   ;======Since its in hex got to adjust to convert it to decimal=======(No longer interested in converting outside of display)================================================     
07E5            533   ;        mov a, hTemp
07E5            534    ;       da a
07E5            535    ;       mov hTemp, a
07E5            536    ;======Display=====================================================================================
07E5            537   
07E5            538            
07E5 856536     539            mov x + 0, hTemp+ 0
07E8 753700     540            mov x + 1, #0
07EB 753800     541            mov x+2, #0
07EE 753900     542            mov x+3, #0
07F1 120252     543            lcall hex2bcd
07F4 900565     544            mov DPTR, #Hello_World
07F7 120247     545            lcall SendString
07FA C000       546            push ar0
07FC A83F       546            mov r0, bcd+1
07FE 120213     546            lcall ?Send_BCD
0801 D000       546            pop ar0
0803 C000       547            push ar0
0805 A83E       547            mov r0, bcd
0807 120213     547            lcall ?Send_BCD
080A D000       547            pop ar0
080C C0E0       548            push acc
080E 7409       548            mov a, #9
0810 14         548            dec a
0811 1201D4     548            lcall ?Set_Cursor_2 ; Select column and row
0814 D0E0       548            pop acc
0816 C000       549            push ar0
0818 A83F       549            mov r0, bcd+1
081A 1201DB     549            lcall ?Display_BCD
081D D000       549            pop ar0
081F C0E0       550            push acc
0821 740B       550            mov a, #11
0823 14         550            dec a
0824 1201D4     550            lcall ?Set_Cursor_2 ; Select column and row
0827 D0E0       550            pop acc
0829 C000       551            push ar0
082B A83E       551            mov r0, bcd
082D 1201DB     551            lcall ?Display_BCD
0830 D000       551            pop ar0
0832 900565     552            mov DPTR, #Hello_World
0835 120247     553            lcall SendString
0838            554            ;Send_BCD(bcd+1)
0838            555            ;Send_BCD(bcd)
0838 900565     556            mov DPTR, #Hello_World
083B 120247     557            lcall SendString
083E 22         558   ret
083F            559       
083F            560   DisplayVariables:
083F C0E0       561            push acc
0841 7405       561            mov a, #5
0843 14         561            dec a
0844 1201D6     561            lcall ?Set_Cursor_1 ; Select column and row
0847 D0E0       561            pop acc
0849 856C36     562            mov x+0, Time_Soak + 0
084C 753700     563            mov x+1, #0
084F 753800     564            mov x+2, #0
0852 753900     565            mov x+3, #0
0855 120252     566            lcall hex2bcd
0858 C000       567            push ar0
085A A83F       567            mov r0, bcd+1
085C 1201DB     567            lcall ?Display_BCD
085F D000       567            pop ar0
0861 C0E0       568            push acc
0863 7407       568            mov a, #7
0865 14         568            dec a
0866 1201D6     568            lcall ?Set_Cursor_1 ; Select column and row
0869 D0E0       568            pop acc
086B C000       569            push ar0
086D A83E       569            mov r0, bcd
086F 1201DB     569            lcall ?Display_BCD
0872 D000       569            pop ar0
0874            570   ;Display Temp Soak       
0874 C0E0       571            push acc
0876 7400       571            mov a, #0
0878 14         571            dec a
0879 1201D6     571            lcall ?Set_Cursor_1 ; Select column and row
087C D0E0       571            pop acc
087E 856B36     572            mov x+0, Temp_Soak + 0
0881 120252     573            lcall hex2bcd
0884 C000       574            push ar0
0886 A83F       574            mov r0, bcd+1
0888 1201DB     574            lcall ?Display_BCD
088B D000       574            pop ar0
088D C0E0       575            push acc
088F 7402       575            mov a, #2
0891 14         575            dec a
0892 1201D6     575            lcall ?Set_Cursor_1 ; Select column and row
0895 D0E0       575            pop acc
0897 C000       576            push ar0
0899 A83E       576            mov r0, bcd
089B 1201DB     576            lcall ?Display_BCD
089E D000       576            pop ar0
08A0            577   ;display time Reflow
08A0 856E36     578            mov x+0, Time_Refl + 0
08A3 120252     579            lcall hex2bcd
08A6 C0E0       580            push acc
08A8 740F       580            mov a, #15
08AA 14         580            dec a
08AB 1201D6     580            lcall ?Set_Cursor_1 ; Select column and row
08AE D0E0       580            pop acc
08B0 C000       581            push ar0
08B2 A83E       581            mov r0, bcd
08B4 1201DB     581            lcall ?Display_BCD
08B7 D000       581            pop ar0
08B9            582   ;display temp reflow
08B9 C0E0       583            push acc
08BB 740A       583            mov a, #10
08BD 14         583            dec a
08BE 1201D6     583            lcall ?Set_Cursor_1 ; Select column and row
08C1 D0E0       583            pop acc
08C3 856D36     584            mov x+0, Temp_Refl + 0
08C6 120252     585            lcall hex2bcd
08C9 C000       586            push ar0
08CB A83F       586            mov r0, bcd+1
08CD 1201DB     586            lcall ?Display_BCD
08D0 D000       586            pop ar0
08D2 C0E0       587            push acc
08D4 740C       587            mov a, #12
08D6 14         587            dec a
08D7 1201D6     587            lcall ?Set_Cursor_1 ; Select column and row
08DA D0E0       587            pop acc
08DC C000       588            push ar0
08DE A83E       588            mov r0, bcd
08E0 1201DB     588            lcall ?Display_BCD
08E3 D000       588            pop ar0
08E5 22         589            ret
08E6            590            
08E6            591   TempSoakAdjust:;=====================Soak Temperature adjustment==============================================
08E6 C002       592            push AR2
08E8 7A32       592            mov R2, #50
08EA 120145     592            lcall ?Wait_Milli_Seconds
08ED D002       592            pop AR2;
08EF E56B       593            mov a, temp_soak
08F1 2401       594            add a, #0x01
08F3            595            ;cpl LEDRA.6
08F3 B4AB30     596            cjne a, #0xab, TempSoakNotOverflow ;0xab = 171
08F6 756B82     597            mov temp_soak, #0x82 ;0x82 = 130
08F9 C0E0       598            push acc
08FB 7400       598            mov a, #0
08FD 14         598            dec a
08FE 1201D6     598            lcall ?Set_Cursor_1 ; Select column and row
0901 D0E0       598            pop acc
0903 856B36     599            mov x+0, Temp_Soak + 0
0906 120252     600            lcall hex2bcd
0909 C000       601            push ar0
090B A83F       601            mov r0, bcd+1
090D 1201DB     601            lcall ?Display_BCD
0910 D000       601            pop ar0
0912 C0E0       602            push acc
0914 7402       602            mov a, #2
0916 14         602            dec a
0917 1201D6     602            lcall ?Set_Cursor_1 ; Select column and row
091A D0E0       602            pop acc
091C C000       603            push ar0
091E A83E       603            mov r0, bcd
0920 1201DB     603            lcall ?Display_BCD
0923 D000       603            pop ar0
0925 22         604            ret
0926            605            ;ljmp SkipSetup
0926            606   TempSoakNotOverflow:;=====================Soak Temperature no overflow==============================================
0926 F56B       607            mov temp_soak, a
0928 C0E0       608            push acc
092A 7400       608            mov a, #0
092C 14         608            dec a
092D 1201D6     608            lcall ?Set_Cursor_1 ; Select column and row
0930 D0E0       608            pop acc
0932 856B36     609            mov x+0, Temp_Soak + 0
0935 120252     610            lcall hex2bcd
0938 C000       611            push ar0
093A A83F       611            mov r0, bcd+1
093C 1201DB     611            lcall ?Display_BCD
093F D000       611            pop ar0
0941 C0E0       612            push acc
0943 7402       612            mov a, #2
0945 14         612            dec a
0946 1201D6     612            lcall ?Set_Cursor_1 ; Select column and row
0949 D0E0       612            pop acc
094B C000       613            push ar0
094D A83E       613            mov r0, bcd
094F 1201DB     613            lcall ?Display_BCD
0952 D000       613            pop ar0
0954 22         614       ret
0955            615   TimeSoakAdjust:;=====================Soak time Adjustment==============================================
0955 C002       616            push AR2
0957 7A32       616            mov R2, #50
0959 120145     616            lcall ?Wait_Milli_Seconds
095C D002       616            pop AR2
095E E56C       617            mov a, Time_Soak
0960 2401       618            add a, #0x01
0962 B47939     619            cjne a, #0x79, TimeSoakNotOverflow;0x79=121
0965 756C3C     620            mov time_soak, #0x3c ;0x3c=60
0968 C0E0       621            push acc
096A 7405       621            mov a, #5
096C 14         621            dec a
096D 1201D6     621            lcall ?Set_Cursor_1 ; Select column and row
0970 D0E0       621            pop acc
0972 856C36     622            mov x+0, Time_Soak + 0
0975 753700     623            mov x+1, #0
0978 753800     624            mov x+2, #0
097B 753900     625            mov x+3, #0
097E 120252     626            lcall hex2bcd
0981 C000       627            push ar0
0983 A83F       627            mov r0, bcd+1
0985 1201DB     627            lcall ?Display_BCD
0988 D000       627            pop ar0
098A C0E0       628            push acc
098C 7407       628            mov a, #7
098E 14         628            dec a
098F 1201D6     628            lcall ?Set_Cursor_1 ; Select column and row
0992 D0E0       628            pop acc
0994 C000       629            push ar0
0996 A83E       629            mov r0, bcd
0998 1201DB     629            lcall ?Display_BCD
099B D000       629            pop ar0
099D 22         630            ret
099E            631   TimeSoakNotOverflow:;=====================Soak time no overflow==============================================
099E F56C       632            mov time_soak, a
09A0 C0E0       633            push acc
09A2 7405       633            mov a, #5
09A4 14         633            dec a
09A5 1201D6     633            lcall ?Set_Cursor_1 ; Select column and row
09A8 D0E0       633            pop acc
09AA 856C36     634            mov x+0, Time_Soak + 0
09AD 753700     635            mov x+1, #0
09B0 753800     636            mov x+2, #0
09B3 753900     637            mov x+3, #0
09B6 120252     638            lcall hex2bcd
09B9 C000       639            push ar0
09BB A83F       639            mov r0, bcd+1
09BD 1201DB     639            lcall ?Display_BCD
09C0 D000       639            pop ar0
09C2 C0E0       640            push acc
09C4 7407       640            mov a, #7
09C6 14         640            dec a
09C7 1201D6     640            lcall ?Set_Cursor_1 ; Select column and row
09CA D0E0       640            pop acc
09CC C000       641            push ar0
09CE A83E       641            mov r0, bcd
09D0 1201DB     641            lcall ?Display_BCD
09D3 D000       641            pop ar0
09D5 22         642            ret
09D6            643   TempReflowAdjust:;=====================Reflow Temp adjusment=============================================
09D6 C002       644            push AR2
09D8 7A32       644            mov R2, #50
09DA 120145     644            lcall ?Wait_Milli_Seconds
09DD D002       644            pop AR2
09DF E56D       645            mov a, Temp_Refl
09E1 2401       646            add a, #0x01
09E3 B4E630     647            cjne a, #0xe6, TempReflowNotOverflow ;0xe6 = 230 TBC POSSIBLY
09E6 756DD9     648            mov Temp_Refl, #0xd9 ;0xd9 = 217
09E9 C0E0       649            push acc
09EB 740A       649            mov a, #10
09ED 14         649            dec a
09EE 1201D6     649            lcall ?Set_Cursor_1 ; Select column and row
09F1 D0E0       649            pop acc
09F3 856D36     650            mov x+0, Temp_Refl + 0
09F6 120252     651            lcall hex2bcd
09F9 C000       652            push ar0
09FB A83F       652            mov r0, bcd+1
09FD 1201DB     652            lcall ?Display_BCD
0A00 D000       652            pop ar0
0A02 C0E0       653            push acc
0A04 740C       653            mov a, #12
0A06 14         653            dec a
0A07 1201D6     653            lcall ?Set_Cursor_1 ; Select column and row
0A0A D0E0       653            pop acc
0A0C C000       654            push ar0
0A0E A83E       654            mov r0, bcd
0A10 1201DB     654            lcall ?Display_BCD
0A13 D000       654            pop ar0
0A15 22         655            ret
0A16            656   TempReflowNotOverflow:
0A16 F56D       657            mov temp_refl, a
0A18 C0E0       658            push acc
0A1A 740A       658            mov a, #10
0A1C 14         658            dec a
0A1D 1201D6     658            lcall ?Set_Cursor_1 ; Select column and row
0A20 D0E0       658            pop acc
0A22 856D36     659            mov x+0, Temp_Refl + 0
0A25 120252     660            lcall hex2bcd
0A28 C000       661            push ar0
0A2A A83F       661            mov r0, bcd+1
0A2C 1201DB     661            lcall ?Display_BCD
0A2F D000       661            pop ar0
0A31 C0E0       662            push acc
0A33 740C       662            mov a, #12
0A35 14         662            dec a
0A36 1201D6     662            lcall ?Set_Cursor_1 ; Select column and row
0A39 D0E0       662            pop acc
0A3B C000       663            push ar0
0A3D A83E       663            mov r0, bcd
0A3F 1201DB     663            lcall ?Display_BCD
0A42 D000       663            pop ar0
0A44 22         664            ret
0A45            665   TimeReflowAdjust:;=====================Reflow TIME adjusment=============================================
0A45 C002       666            push AR2
0A47 7A32       666            mov R2, #50
0A49 120145     666            lcall ?Wait_Milli_Seconds
0A4C D002       666            pop AR2
0A4E E56E       667            mov a, Time_Refl
0A50 2401       668            add a, #0x01
0A52 B44C1D     669            cjne a, #0x4c, TimeReflowNotOverflow ; 0x4c=76
0A55 756E2D     670            mov Time_Refl, #0x2d ;0x2d = 45
0A58 856E36     671            mov x+0, Time_Refl + 0
0A5B 120252     672            lcall hex2bcd
0A5E C0E0       673            push acc
0A60 740F       673            mov a, #15
0A62 14         673            dec a
0A63 1201D6     673            lcall ?Set_Cursor_1 ; Select column and row
0A66 D0E0       673            pop acc
0A68 C000       674            push ar0
0A6A A83E       674            mov r0, bcd
0A6C 1201DB     674            lcall ?Display_BCD
0A6F D000       674            pop ar0
0A71 22         675            ret
0A72            676   TimeReflowNotOverflow:;=====================Soak time no overflow==============================================
0A72 F56E       677            mov time_Refl, a
0A74 856E36     678            mov x+0, Time_Refl + 0
0A77 120252     679            lcall hex2bcd
0A7A C0E0       680            push acc
0A7C 740F       680            mov a, #15
0A7E 14         680            dec a
0A7F 1201D6     680            lcall ?Set_Cursor_1 ; Select column and row
0A82 D0E0       680            pop acc
0A84 C000       681            push ar0
0A86 A83E       681            mov r0, bcd
0A88 1201DB     681            lcall ?Display_BCD
0A8B D000       681            pop ar0
0A8D 22         682            ret
0A8E            683   
0A8E            684   end
