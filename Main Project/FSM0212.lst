0000              1   ; This program tests the LTC2308 avaliable in the newer version of the DE1-SoC board.
0000              2   ; Access to the input pins of the ADC is avalible at connector J15. Here is the top
0000              3   ; view of the connector:
0000              4   ;
0000              5   ; +--+
0000              6   ; |  | <-- Red power button
0000              7   ; +--+
0000              8   ;
0000              9   ; +-----+-----+
0000             10   ; + GND | IN7 |
0000             11   ; +-----+-----+
0000             12   ; + IN6 | IN5 |
0000             13   ; +-----+-----+
0000             14   ; + IN4 | IN3 |
0000             15   ; +-----+-----+
0000             16   ; + IN2 | IN1 |
0000             17   ; ------+-----+
0000             18   ; + IN0 | 5V  |
0000             19   ; +-----+-----+
0000             20   ;      J15
0000             21   ; 
0000             22   ; Displays the result using the 7-segment displays and also sends it via the serial port to PUTTy.
0000             23   ;
0000             24   ; (c) Jesus Calvino-Fraga 2019
0000             25   ;
                 27   $LIST
0000             29   
0000             30   ; Bits used to access the LTC2308
0000             31   LTC2308_MISO bit 0xF8 ; Read only bit
0000             32   LTC2308_MOSI bit 0xF9 ; Write only bit
0000             33   LTC2308_SCLK bit 0xFA ; Write only bit
0000             34   LTC2308_ENN  bit 0xFB ; Write only bit
0000             35   
0000             36   ;BUTTONS
0000             37   button1          equ P2.1
0000             38   button2          equ P2.2
0000             39   button3          equ P2.3
0000             40   button4          equ P2.4
0000             41   button5          equ P2.5
0000             42   ;STATES
0000             43   Select           equ 0
0000             44   RAMPTOSOAK       equ 1
0000             45   PREHEAT          equ 2
0000             46   RAMPTOPEAK       equ 3
0000             47   REFLOW           equ 4
0000             48   COOLING          equ 5
0000             49   
0000             50   CLK EQU 33333333
0000             51   BAUD EQU 57600
0000             52   TIMER_2_RELOAD EQU (65536-(CLK/(32*BAUD)))
0000             53   TIMER_0_1ms EQU (65536-(CLK/(12*1000)))
0000             54   
0000             55   ;;
0000             56   ;;
0000             57   ;; PUSH BUTTON DEFINITIONS
0000             58   ;;
0000             59   ;;
0000             60   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             61   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is 12 unlike the AT89LP51RC2 where is 1.
0000             62   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             63   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             64   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0000             65   
0000             66   
0000             67   ; Reset vector
0000             68   org 0x0000
0000 02065B      69       ljmp MainProgram
0003             70   
0003             71   ; External interrupt 0 vector (not used in this code)
0003             72   org 0x0003
0003 32          73            reti
0004             74   
0004             75   ; Timer/Counter 0 overflow interrupt vector
000B             76   org 0x000B
000B 0205A5      77            ljmp Timer0_ISR
000E             78   
000E             79   ; External interrupt 1 vector (not used in this code)
0013             80   org 0x0013
0013 32          81            reti
0014             82   
0014             83   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             84   org 0x001B
001B 32          85            reti
001C             86   
001C             87   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             88   org 0x0023 
0023 32          89            reti
0024             90            
0024             91   ; Timer/Counter 2 overflow interrupt vector
002B             92   org 0x002B
002B 0205C7      93            ljmp Timer2_ISR
002E             94            
002E             95   SOUND_OUT     equ P1.0
002E             96   UPDOWN        equ SWA.0
002E             97   
002E             98   ; Reset vector
002E             99   
002E            100   
002E            101   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            102   dseg at 0x30
0030            103   Count1ms:     ds 2 ; Used to determine when half second has passed
0032            104   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            105   Seconds:  ds 1
0034            106   Minutes: ds 1
0035            107   pwm: ds 1
0036            108   x:       ds 4
003A            109   y:       ds 4
003E            110   bcd:     ds 5
0043            111   buffer: ds 30
0061            112   vResult:         ds 2
0063            113   cTemp:   ds 2
0065            114   hTemp:   ds 3
0068            115   tTemp:   ds 3
006B            116   ;FSM Variables
006B            117   temp_soak: ds 1
006C            118   time_soak: ds 1
006D            119   temp_refl: ds 1
006E            120   time_refl: ds 1
006F            121   temp: ds 1
0070            122   timer: ds 1
0071            123   state: ds 1
0072            124   sec: ds 1
0073            125   MyHope: ds 1
0074            126   WorkingTime: ds 1
0075            127   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0075            128   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            129   bseg
0000            130   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            131   PwmFlag: dbit 1
0002            132   mf: dbit 1
0003            133   
002E            134   cseg     
002E            135   BJTBase equ P0.0
002E            136   ELCD_RS equ P1.2
002E            137   ELCD_RW equ P1.3
002E            138   ELCD_E  equ P1.4
002E            139   ELCD_D4 equ P1.5
002E            140   ELCD_D5 equ P1.6
002E            141   ELCD_D6 equ P1.7
002E            142   ELCD_D7 equ P0.6
002E            143   
002E            144   CE_ADC   EQU P0.2
002E            145   MY_MOSI EQU P0.0
002E            146   MY_MISO EQU P2.0
002E            147   MY_SCLK EQU P0.1
002E            148   
002E            149   PWMout equ P0.3
002E            150   
                622   $LIST
                153   $LIST
0541            155   
0541 0D0A4C54   156   InitialString: db '\r\nLTC2308 test program\r\n', 0
     43323330
     38207465
     73742070
     726F6772
     616D0D0A
     00
055A 48656C6F   157   MyString: db 'Helo213qwq', 0
     32313371
     777100
0565            158   Hello_World: ;indent to separate numbers in the putty
0565 0D0A00     159       DB  '\r','\n', 0
0568            160   
0568            161   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0568            162   T_7seg:
0568 40792430   163       DB 40H, 79H, 24H, 30H, 19H, 12H, 02H, 78H, 00H, 10H
     19120278
     0010
0572            164   
0572            165   ; Display the 4-digit bcd stored in [R3,R2] using the 7-segment displays
0572            166   
0572            167   
0572            168   ; Send a 4-digit BCD number stored in [R3,R2] to the serial port         
0572            169   
0572            170            
0572            171   ; Wait 1 millisecond using Timer 0
0572            172   Wait1ms:
0572 C28C       173            clr     TR0
0574 74F0       174            mov     a,#0xF0
0576 5589       175            anl     a,TMOD
0578 4401       176            orl     a,#0x01
057A F589       177            mov     TMOD,a
057C 758CF5     178            mov     TH0, #high(TIMER_0_1ms)
057F 758A27     179            mov     TL0, #low(TIMER_0_1ms)
0582 C28D       180            clr     TF0
0584 D28C       181            setb TR0
0586 308DFD     182            jnb     TF0,$
0589 C28C       183            clr     TR0
058B 22         184            ret
058C            185            
058C            186   ; Wait R2 milliseconds
058C            187   MyDelay:
058C 120572     188            lcall Wait1ms
058F DAFB       189       djnz R2, MyDelay
0591 22         190            ret
0592            191            
0592            192   Timer0_Init:
0592 E589       193            mov a, TMOD
0594 54F0       194            anl a, #0xf0 ; Clear the bits for timer 0
0596 4401       195            orl a, #0x01 ; Configure timer 0 as 16-timer
0598 F589       196            mov TMOD, a
059A 758CFD     197            mov TH0, #high(TIMER0_RELOAD)
059D 758A5A     198            mov TL0, #low(TIMER0_RELOAD)
05A0            199            ; Enable the timer and interrupts
05A0 D2A9       200       setb ET0  ; Enable timer 0 interrupt
05A2 D28C       201       setb TR0  ; Start timer 0
05A4 22         202            ret
05A5            203   
05A5            204   ;---------------------------------;
05A5            205   ; ISR for timer 0.  Set to execute;
05A5            206   ; every 1/4096Hz to generate a    ;
05A5            207   ; 2048 Hz square wave at pin P3.7 ;
05A5            208   ;---------------------------------;
05A5            209   Timer0_ISR:
05A5            210   ;        clr TF0  ; According to the data sheet this is done for us already.
05A5 758CFD     211            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
05A8 758A5A     212            mov TL0, #low(TIMER0_RELOAD)
05AB            213   
05AB            214            
05AB 32         215            reti
05AC            216   
05AC            217   ;---------------------------------;
05AC            218   ; Routine to initialize the ISR   ;
05AC            219   ; for timer 2                     ;
05AC            220   ;---------------------------------;
05AC            221   
05AC            222   Timer2_Init:
05AC 75C800     223            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
05AF 75CDF5     224            mov TH2, #high(TIMER2_RELOAD)
05B2 75CC27     225            mov TL2, #low(TIMER2_RELOAD)
05B5            226            ; Set the reload value
05B5 75CBF5     227            mov RCAP2H, #high(TIMER2_RELOAD)
05B8 75CA27     228            mov RCAP2L, #low(TIMER2_RELOAD)
05BB B2E9       229            cpl LEDRA.1
05BD            230            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
05BD E4         231            clr a
05BE F530       232            mov Count1ms+0, a
05C0 F531       233            mov Count1ms+1, a
05C2            234            ; Enable the timer and interrupts
05C2 D2AD       235       setb ET2  ; Enable timer 2 interrupt
05C4 D2CA       236       setb TR2  ; Enable timer 2
05C6 22         237            ret
05C7            238   
05C7            239   ;---------------------------------;
05C7            240   ; ISR for timer 2                 ;
05C7            241   ;---------------------------------;
05C7            242   Timer2_ISR:
05C7 C2CF       243            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
05C9            244   ;        cpl P1.1 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
05C9            245            
05C9            246            ; The two registers used in the ISR must be saved in the stack
05C9 C0E0       247            push acc
05CB C0D0       248            push psw
05CD            249            
05CD            250            ; Increment the 16-bit one mili second counter
05CD 0530       251            inc Count1ms+0    ; Increment the low 8-bits first
05CF E530       252            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05D1 7002       253            jnz Inc_Done
05D3 0531       254            inc Count1ms+1
05D5            255   
05D5            256   Inc_Done:;===========================================ISR MAIN=============================================
05D5            257            ; Check if half second has passed
05D5 E530       258            mov a, Count1ms+0
05D7 B4F47C     259            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
05DA E531       260            mov a, Count1ms+1
05DC B40177     261            cjne a, #high(500), Timer2_ISR_done
05DF            262            
05DF            263            ; 500 milliseconds have passed.  Set a flag so the main program knows
05DF D200       264            setb half_seconds_flag ; Let the main program know half second had passed
05E1            265            ; Toggle LEDR0 so it blinks
05E1            266            ;=====================Timer 0 controls============================================
05E1            267            ;cpl LEDRA.0
05E1            268   ;        cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
05E1            269            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
05E1            270            ;==================================================================================================
05E1 E4         271            clr a
05E2            272            ;=====================Display=============================================
05E2            273   ;        mov x+0, Temp_soak+0
05E2            274   ;        mov x+1, #0
05E2            275   ;        mov x+2, #0
05E2            276   ;        mov x+3, #0
05E2            277   ;
05E2            278   ;        Load_Y(1)
05E2            279   ;        lcall mul32
05E2            280   ;        lcall hex2bcd
05E2            281   
05E2            282   ;        Send_BCD(bcd+1)
05E2            283            
05E2 C0E0       284            push acc
05E4 7401       284            mov a, #1
05E6 14         284            dec a
05E7 1201D4     284            lcall ?Set_Cursor_2 ; Select column and row
05EA D0E0       284            pop acc
05EC C000       285            push ar0
05EE A834       285            mov r0, minutes
05F0 1201DB     285            lcall ?Display_BCD
05F3 D000       285            pop ar0
05F5 C0E0       286            push acc
05F7 7404       286            mov a, #4
05F9 14         286            dec a
05FA 1201D4     286            lcall ?Set_Cursor_2 ; Select column and row
05FD D0E0       286            pop acc
05FF            287   ;        Send_BCD(bcd)
05FF C000       288            push ar0
0601 A833       288            mov r0, seconds
0603 1201DB     288            lcall ?Display_BCD
0606 D000       288            pop ar0
0608            289   ;        mov DPTR, #Hello_World
0608            290   ;        lcall SendString
0608            291   ;==============================================================================================
0608 F530       292            mov Count1ms+0, a
060A F531       293            mov Count1ms+1, a
060C            294            ; Increment the BCD counter
060C            295            
060C E573       296            mov a, MyHope
060E 2401       297            add a, #1
0610 F573       298            mov MyHope, a
0612            299   
0612 857436     300            mov x + 0, WorkingTime + 0
0615 753700     301            mov x + 1, #0
0618 753800     302            mov x + 2, #0
061B 753900     303            mov x + 3, #0
061E            304            
061E 85353A     305            mov y + 0, pwm + 0
0621 85363B     306            mov y + 1, pwm + 1
0624 753C00     307            mov y + 2, #0
0627 753D00     308            mov y + 3, #0
062A            309            
062A 1203CC     310            lcall mul32
062D 753A64     311            mov y+0, #low (100 % 0x10000) 
0630 753B00     311            mov y+1, #high(100 % 0x10000) 
0633 753C00     311            mov y+2, #low (100 / 0x10000) 
0636 753D00     311            mov y+3, #high(100 / 0x10000) 
0639 120459     312            lcall div32
063C 853674     313            mov     Workingtime + 0, x + 0
063F            314            
063F 1207E9     315            lcall ReadTemperature
0642 E533       316            mov a, Seconds
0644            317   ;        jb UPDOWN, Timer2_ISR_decrement
0644 2401       318            add a, #0x01
0646            319            ;sjmp Timer2_ISR_da
0646            320   ;Timer2_ISR_decrement:;=====================ISR DECREMENT=============================================
0646            321   ;        add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.    
0646            322            
0646            323            
0646            324   Timer2_ISR_da:
0646 D4         325            da a ; Decimal adjust instruction.  Check datasheet for more details!   
0647 F533       326            mov seconds, a
0649            327   
0649 B4600A     328            cjne a, #0x60, Timer2_ISR_done ;if seconds are not 60, go to ISR_done
064C 753300     329            mov Seconds, #0x0 ;reset seconds to 0
064F E534       330            mov a, Minutes ; set a to previous minutes
0651 2401       331            add a, #0x01 ;add one to obtain current minutes
0653 D4         332            da a ;makes formatting nice 
0654 F534       333            mov Minutes, a ;put updated minutes into the counter
0656            334   ;        sjmp Timer2_ISR_M_aadjust
0656            335            
0656            336   Timer2_ISR_done:
0656 D0D0       337            pop psw
0658 D0E0       338            pop acc
065A 32         339            reti
065B            340            
065B            341   
065B            342   MainProgram:;============================MAIN===========================================================
065B 75817F     343       mov sp, #0x7f
065E 120592     344       lcall Timer0_Init
0661 1205AC     345       lcall Timer2_Init
0664 120095     346       lcall Initialize_LEDs
0667 12007E     347       lcall Initialize_Serial_Port
066A 12009C     348       lcall Initialize_ADC
066D 120592     349       lcall Timer0_Init
0670 1205AC     350       lcall Timer2_Init
0673 120229     351       lcall INIT_SPI
0676            352   ;FSM Variables  ==================
0676 E4         353            clr a
0677 F56B       354            mov temp_soak, a
0679 756B1E     355       mov temp_soak, #0x1e ; Will remain in hex, 0x82 is orig value else is for debugging
067C 756C3C     356            mov time_soak, #0x3c     ;HAS TO BE IN HEX only convert to bcd for display!
067F 756D23     357            mov temp_refl, #0x23 ;230 0xdc is original, else debug
0682 756E41     358            mov time_refl, #0x41 ;65
0685            359            
0685 756F19     360            mov temp, #25
0688 757000     361            mov timer, #0x00
068B 757100     362            mov state, #0x00
068E 757200     363            mov sec, #0x00
0691 753400     364            mov minutes, #0
0694 750200     365            mov mf, #0
0697 757300     366            mov MyHope, #0
069A 757405     367            mov WorkingTime, #0x05
069D            368   ;========================
069D            369     ;  lcall InitSerialPort
069D            370            ;clr TR0
069D 759AFF     371       mov P0MOD, #11111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
06A0            372       ; We use pins P1.0 and P1.1 as outputs also.  Configure accordingly.
06A0 759BFF     373       mov P1MOD, #11111111b ; P1.0 and P1.0 are outputs
06A3 120194     374       lcall ELCD_4BIT
06A6            375     ;  clr EX1
06A6 D2AF       376       setb EA
06A8            377   
06A8            378   ;        Set_Cursor(1,1)
06A8            379   ;        Send_Constant_String(#MyString)
06A8 B2EC       380            cpl LEDRA.4
06AA D200       381            setb half_seconds_flag
06AC 753350     382            mov Seconds, #0x50
06AF 12087F     383            lcall DisplayVariables
06B2            384   forever:;======================================================FOREVER===========================================================
06B2 E5E8       385            mov a, SWA ; read the channel to convert from the switches
06B4 5407       386            anl a, #00000111B ; We need only the last three bits since there are only eight channels
06B6 F5F0       387            mov b, a
06B8 1200AC     388            lcall LTC2308_RW  ; Read the channel from the ADC
06BB 120060     389            lcall hex2bcd16   ; Convert to bcd
06BE            390   ;        lcall Display_BCD1 ; Display using the 7-segment displays
06BE            391   ;        lcall SendNumber  ; Send to serial port
06BE            392   ;        jnb BJTBase, pinpressed
06BE 7AFA       393            mov R2, #250
06C0            394            
06C0 20F91C     395            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
06C3 C002       396            push AR2
06C5 7A32       396            mov R2, #50
06C7 120145     396            lcall ?Wait_Milli_Seconds
06CA D002       396            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit_DE1SoC.inc'
06CC 20F910     397            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
06CF 30F9FD     398            jnb KEY.1, $    
06D2 C2CA       399            clr TR2 ; Stop timer 2
06D4 E4         400            clr a
06D5 F530       401            mov Count1ms+0, a
06D7 F531       402            mov Count1ms+1, a
06D9            403            ; Now clear the BCD counter
06D9 F532       404            mov BCD_counter, a
06DB D2CA       405            setb TR2    ; Start timer 2
06DD 8003       406            sjmp loop_b ; Display the new value
06DF            407   loop_a:;======================================================FOREVER================================================
06DF 3000D0     408            jnb half_seconds_flag, forever
06E2            409   loop_b:;======================================================FOREVER================================================
06E2 C200       410            clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
06E4 C0E0       411            push acc
06E6 740F       411            mov a, #15
06E8 14         411            dec a
06E9 1201D4     411            lcall ?Set_Cursor_2 ; Select column and row
06EC D0E0       411            pop acc     ; the place in the LCD where we want the BCD counter value
06EE C000       412            push ar0
06F0 A871       412            mov r0, state
06F2 1201DB     412            lcall ?Display_BCD
06F5 D000       412            pop ar0
06F7            413   ;        cpl LEDRA.4
06F7            414   
06F7 E571       415       mov a, state
06F9            416    ;=======================================================STATE 0========================================
06F9            417   ResetState:
06F9 B4002B     418            cjne a, #select, RampToSoakState
06FC            419   ;Display Time Soak
06FC            420   
06FC            421            
06FC 30A122     422            jnb button1, Pathnextstate
06FF 30A20B     423            jnb button2, PathTempSoakAdjust
0702 30A30D     424            jnb button3, PathTimeSoakAdjust
0705 30A414     425            jnb button4, PathTempReflowAdjust
0708 30A50C     426            jnb button5, PathTimeReflowAdjust ; TimeReflowAdjust jump
070B 801A       427            sjmp RampToSoakState
070D            428   PathTempSoakAdjust:
070D 120926     429            lcall TempSoakAdjust
0710 8012       430            sjmp SkipSetup1
0712            431   PathTimeSoakAdjust:
0712 120995     432            lcall TimeSoakAdjust
0715 800D       433            sjmp SkipSetup1
0717            434   PathTimeReflowAdjust: 
0717 120A85     435            lcall TimeReflowAdjust
071A 8008       436            sjmp SkipSetup1
071C            437   PathTempReflowAdjust:
071C 120A16     438            lcall TempReflowAdjust
071F 8003       439            sjmp SkipSetup1
0721            440   PathNextState:
0721 0207BC     441            ljmp nextstate
0724            442   SkipSetup1:;=====================CHANGE  OF STATES==============================================
0724 0206B2     443            ljmp forever
0727            444   
0727            445            ;mov Seconds, #0x00
0727            446            ;mov minutes, #0
0727            447   RampToSoakState:         ;==============================STATE 1================================================
0727 B40129     448            cjne a, #RampToSoak, PreHeatState
072A 753564     449            mov pwm, #0x64
072D            450     ;  mov sec, #0
072D            451    ;=============================Checking ih current temp has reaches soak temp==========================================   
072D 856536     452            mov x, hTemp
0730 753700     453            mov x+1, #0
0733 753800     454            mov x+2, #0
0736 753900     455            mov x+3, #0
0739            456   
0739 856B3A     457            mov y, temp_soak
073C 753B00     458            mov y+1, #0
073F 753C00     459            mov y+2, #0
0742 753D00     460            mov y+3, #0
0745 12035A     461            lcall x_lt_y
0748            462   ;====================================If its reached, move on to the next state, if not abort if 60 seconds passed=============
0748 300271     463            jnb     mf, nextstate
074B E534       464            mov a, Minutes
074D B40169     465       cjne a, #0x01, SkipSetup
0750 0207DB     466       ljmp abort
0753            467   
0753            468   PreHeatState:;====================================================STATE 2===========================================
0753 B4020B     469            cjne a, #PreHeat, RampToHeatState
0756 753514     470            mov pwm, #0x14
0759 E573       471            mov a, MyHope
075B B56C5B     472            cjne a, Time_Soak, SkipSetup
075E 1207BC     473            lcall nextstate
0761            474   RampToHeatState:;====================================================STATE 3===========================================
0761 B40323     475            cjne a, #RampToPeak, ReflowState
0764 753564     476            mov pwm, #0x64
0767 856536     477            mov x, hTemp
076A 753700     478            mov x+1, #0
076D 753800     479            mov x+2, #0
0770 753900     480            mov x+3, #0
0773            481   
0773 856D3A     482            mov y, temp_refl
0776 753B00     483            mov y+1, #0
0779 753C00     484            mov y+2, #0
077C 753D00     485            mov y+3, #0
077F 12035A     486            lcall x_lt_y
0782            487                            
0782 300237     488            jnb     mf, nextstate
0785 8032       489            sjmp SkipSetup
0787            490   ReflowState:
0787 B4040B     491            cjne a, #Reflow, CoolingState
078A 753514     492            mov pwm, #0x14
078D E573       493            mov a, MyHope
078F B56E27     494            cjne a, Time_Refl, SkipSetup
0792 1207BC     495            lcall nextstate
0795            496   CoolingState:
0795 B40521     497            cjne a, #Cooling, SkipSetup
0798 753500     498            mov pwm, #0
079B 856536     499            mov x, hTemp
079E 753700     500            mov x+1, #0
07A1 753800     501            mov x+2, #0
07A4 753900     502            mov x+3, #0
07A7            503   
07A7 753A20     504            mov y, #0x20
07AA 753B00     505            mov y+1, #0
07AD 753C00     506            mov y+2, #0
07B0 753D00     507            mov y+3, #0
07B3 12035A     508            lcall x_lt_y
07B6            509                            
07B6 200203     510            jb      mf, nextstate
07B9            511            
07B9            512   SkipSetup:;=====================CHANGE  OF STATES==============================================
07B9 0206B2     513            ljmp forever
07BC            514   nextstate: ;=====================CHANGE  OF STATES==============================================
07BC C002       515            push AR2
07BE 7A32       515            mov R2, #50
07C0 120145     515            lcall ?Wait_Milli_Seconds
07C3 D002       515            pop AR2
07C5 753300     516            mov seconds, #0
07C8 753400     517            mov minutes, #0
07CB 757300     518            mov MyHope, #0
07CE E571       519            mov a, state
07D0 2401       520            add a, #1
07D2 B4060F     521            cjne a, #6, NoStateReset
07D5 757100     522            mov state, #0
07D8            523   ;        cpl LEDRA.7
07D8            524   
07D8 0207B9     525            ljmp SkipSetup
07DB            526   abort: ;=================================ABORT1=====================================================
07DB 757100     527            mov state, #0
07DE 753500     528            mov pwm, #0
07E1 0207B9     529            ljmp SkipSetup
07E4            530   ;====================================================PATHS==(if ljmp is outside of bounds)==============================================
07E4            531   
07E4            532   NoStateReset:;=====================STATE OVERFLOW==============================================
07E4 F571       533            mov state, a
07E6            534            ;cpl LEDRA.7
07E6 0207B9     535            ljmp SkipSetup  
07E9            536   
07E9            537   ReadTemperature: 
07E9 75F000     538            mov b, #0
07EC 1201F1     538            lcall _Read_ADC_Channel
07EF C000       539            push aR0
07F1 A863       539            mov R0, cTemp
07F3 1204C2     539            lcall _volt2ctemp
07F6 D000       539            pop aR0 
07F8            540   ;        mov cTemp, bcd
07F8 75F006     541            mov b, #6
07FB 1201F1     541            lcall _Read_ADC_Channel
07FE C000       542            push aR0
0800 A865       542            mov R0, hTemp
0802 120509     542            lcall _volt2htemp
0805 D000       542            pop aR0
0807            543   ;        So In order to keep stuff in hex, Got to convert cTemp back from bcd to hex. NOT CONVERTING TO BCD IN THE FIRST PLACE DIDNOT WORK. GAVE 0
0807 85633E     544            mov bcd+0, cTemp+0
080A 85643F     545            mov bcd+1, cTemp+1
080D 754000     546            mov bcd+2, #0
0810 754100     547            mov bcd+3, #0
0813 754200     548            mov bcd+4, #0
0816 1202DB     549            lcall bcd2hex
0819 853663     550            mov cTemp + 0, x + 0
081C 853764     551            mov cTemp + 1, x + 1
081F            552   ;======Adding cold junction temp=======================================================  
081F E565       553            mov a, hTemp
0821 2563       554            add a, cTemp
0823 F565       555            mov hTemp, a
0825            556   ;======Since its in hex got to adjust to convert it to decimal=======(No longer interested in converting outside of display)================================================     
0825            557   ;        mov a, hTemp
0825            558    ;       da a
0825            559    ;       mov hTemp, a
0825            560    ;======Display=====================================================================================
0825            561   
0825            562            
0825 856536     563            mov x + 0, hTemp+ 0
0828 753700     564            mov x + 1, #0
082B 753800     565            mov x+2, #0
082E 753900     566            mov x+3, #0
0831 120252     567            lcall hex2bcd
0834 900565     568            mov DPTR, #Hello_World
0837 120247     569            lcall SendString
083A C000       570            push ar0
083C A83F       570            mov r0, bcd+1
083E 120213     570            lcall ?Send_BCD
0841 D000       570            pop ar0
0843 C000       571            push ar0
0845 A83E       571            mov r0, bcd
0847 120213     571            lcall ?Send_BCD
084A D000       571            pop ar0
084C C0E0       572            push acc
084E 7409       572            mov a, #9
0850 14         572            dec a
0851 1201D4     572            lcall ?Set_Cursor_2 ; Select column and row
0854 D0E0       572            pop acc
0856 C000       573            push ar0
0858 A83F       573            mov r0, bcd+1
085A 1201DB     573            lcall ?Display_BCD
085D D000       573            pop ar0
085F C0E0       574            push acc
0861 740B       574            mov a, #11
0863 14         574            dec a
0864 1201D4     574            lcall ?Set_Cursor_2 ; Select column and row
0867 D0E0       574            pop acc
0869 C000       575            push ar0
086B A83E       575            mov r0, bcd
086D 1201DB     575            lcall ?Display_BCD
0870 D000       575            pop ar0
0872 900565     576            mov DPTR, #Hello_World
0875 120247     577            lcall SendString
0878            578            ;Send_BCD(bcd+1)
0878            579            ;Send_BCD(bcd)
0878 900565     580            mov DPTR, #Hello_World
087B 120247     581            lcall SendString
087E 22         582   ret
087F            583       
087F            584   DisplayVariables:
087F C0E0       585            push acc
0881 7405       585            mov a, #5
0883 14         585            dec a
0884 1201D6     585            lcall ?Set_Cursor_1 ; Select column and row
0887 D0E0       585            pop acc
0889 856C36     586            mov x+0, Time_Soak + 0
088C 753700     587            mov x+1, #0
088F 753800     588            mov x+2, #0
0892 753900     589            mov x+3, #0
0895 120252     590            lcall hex2bcd
0898 C000       591            push ar0
089A A83F       591            mov r0, bcd+1
089C 1201DB     591            lcall ?Display_BCD
089F D000       591            pop ar0
08A1 C0E0       592            push acc
08A3 7407       592            mov a, #7
08A5 14         592            dec a
08A6 1201D6     592            lcall ?Set_Cursor_1 ; Select column and row
08A9 D0E0       592            pop acc
08AB C000       593            push ar0
08AD A83E       593            mov r0, bcd
08AF 1201DB     593            lcall ?Display_BCD
08B2 D000       593            pop ar0
08B4            594   ;Display Temp Soak       
08B4 C0E0       595            push acc
08B6 7400       595            mov a, #0
08B8 14         595            dec a
08B9 1201D6     595            lcall ?Set_Cursor_1 ; Select column and row
08BC D0E0       595            pop acc
08BE 856B36     596            mov x+0, Temp_Soak + 0
08C1 120252     597            lcall hex2bcd
08C4 C000       598            push ar0
08C6 A83F       598            mov r0, bcd+1
08C8 1201DB     598            lcall ?Display_BCD
08CB D000       598            pop ar0
08CD C0E0       599            push acc
08CF 7402       599            mov a, #2
08D1 14         599            dec a
08D2 1201D6     599            lcall ?Set_Cursor_1 ; Select column and row
08D5 D0E0       599            pop acc
08D7 C000       600            push ar0
08D9 A83E       600            mov r0, bcd
08DB 1201DB     600            lcall ?Display_BCD
08DE D000       600            pop ar0
08E0            601   ;display time Reflow
08E0 856E36     602            mov x+0, Time_Refl + 0
08E3 120252     603            lcall hex2bcd
08E6 C0E0       604            push acc
08E8 740F       604            mov a, #15
08EA 14         604            dec a
08EB 1201D6     604            lcall ?Set_Cursor_1 ; Select column and row
08EE D0E0       604            pop acc
08F0 C000       605            push ar0
08F2 A83E       605            mov r0, bcd
08F4 1201DB     605            lcall ?Display_BCD
08F7 D000       605            pop ar0
08F9            606   ;display temp reflow
08F9 C0E0       607            push acc
08FB 740A       607            mov a, #10
08FD 14         607            dec a
08FE 1201D6     607            lcall ?Set_Cursor_1 ; Select column and row
0901 D0E0       607            pop acc
0903 856D36     608            mov x+0, Temp_Refl + 0
0906 120252     609            lcall hex2bcd
0909 C000       610            push ar0
090B A83F       610            mov r0, bcd+1
090D 1201DB     610            lcall ?Display_BCD
0910 D000       610            pop ar0
0912 C0E0       611            push acc
0914 740C       611            mov a, #12
0916 14         611            dec a
0917 1201D6     611            lcall ?Set_Cursor_1 ; Select column and row
091A D0E0       611            pop acc
091C C000       612            push ar0
091E A83E       612            mov r0, bcd
0920 1201DB     612            lcall ?Display_BCD
0923 D000       612            pop ar0
0925 22         613            ret
0926            614            
0926            615   TempSoakAdjust:;=====================Soak Temperature adjustment==============================================
0926 C002       616            push AR2
0928 7A32       616            mov R2, #50
092A 120145     616            lcall ?Wait_Milli_Seconds
092D D002       616            pop AR2;
092F E56B       617            mov a, temp_soak
0931 2401       618            add a, #0x01
0933            619            ;cpl LEDRA.6
0933 B4AB30     620            cjne a, #0xab, TempSoakNotOverflow ;0xab = 171
0936 756B82     621            mov temp_soak, #0x82 ;0x82 = 130
0939 C0E0       622            push acc
093B 7400       622            mov a, #0
093D 14         622            dec a
093E 1201D6     622            lcall ?Set_Cursor_1 ; Select column and row
0941 D0E0       622            pop acc
0943 856B36     623            mov x+0, Temp_Soak + 0
0946 120252     624            lcall hex2bcd
0949 C000       625            push ar0
094B A83F       625            mov r0, bcd+1
094D 1201DB     625            lcall ?Display_BCD
0950 D000       625            pop ar0
0952 C0E0       626            push acc
0954 7402       626            mov a, #2
0956 14         626            dec a
0957 1201D6     626            lcall ?Set_Cursor_1 ; Select column and row
095A D0E0       626            pop acc
095C C000       627            push ar0
095E A83E       627            mov r0, bcd
0960 1201DB     627            lcall ?Display_BCD
0963 D000       627            pop ar0
0965 22         628            ret
0966            629            ;ljmp SkipSetup
0966            630   TempSoakNotOverflow:;=====================Soak Temperature no overflow==============================================
0966 F56B       631            mov temp_soak, a
0968 C0E0       632            push acc
096A 7400       632            mov a, #0
096C 14         632            dec a
096D 1201D6     632            lcall ?Set_Cursor_1 ; Select column and row
0970 D0E0       632            pop acc
0972 856B36     633            mov x+0, Temp_Soak + 0
0975 120252     634            lcall hex2bcd
0978 C000       635            push ar0
097A A83F       635            mov r0, bcd+1
097C 1201DB     635            lcall ?Display_BCD
097F D000       635            pop ar0
0981 C0E0       636            push acc
0983 7402       636            mov a, #2
0985 14         636            dec a
0986 1201D6     636            lcall ?Set_Cursor_1 ; Select column and row
0989 D0E0       636            pop acc
098B C000       637            push ar0
098D A83E       637            mov r0, bcd
098F 1201DB     637            lcall ?Display_BCD
0992 D000       637            pop ar0
0994 22         638       ret
0995            639   TimeSoakAdjust:;=====================Soak time Adjustment==============================================
0995 C002       640            push AR2
0997 7A32       640            mov R2, #50
0999 120145     640            lcall ?Wait_Milli_Seconds
099C D002       640            pop AR2
099E E56C       641            mov a, Time_Soak
09A0 2401       642            add a, #0x01
09A2 B47939     643            cjne a, #0x79, TimeSoakNotOverflow;0x79=121
09A5 756C3C     644            mov time_soak, #0x3c ;0x3c=60
09A8 C0E0       645            push acc
09AA 7405       645            mov a, #5
09AC 14         645            dec a
09AD 1201D6     645            lcall ?Set_Cursor_1 ; Select column and row
09B0 D0E0       645            pop acc
09B2 856C36     646            mov x+0, Time_Soak + 0
09B5 753700     647            mov x+1, #0
09B8 753800     648            mov x+2, #0
09BB 753900     649            mov x+3, #0
09BE 120252     650            lcall hex2bcd
09C1 C000       651            push ar0
09C3 A83F       651            mov r0, bcd+1
09C5 1201DB     651            lcall ?Display_BCD
09C8 D000       651            pop ar0
09CA C0E0       652            push acc
09CC 7407       652            mov a, #7
09CE 14         652            dec a
09CF 1201D6     652            lcall ?Set_Cursor_1 ; Select column and row
09D2 D0E0       652            pop acc
09D4 C000       653            push ar0
09D6 A83E       653            mov r0, bcd
09D8 1201DB     653            lcall ?Display_BCD
09DB D000       653            pop ar0
09DD 22         654            ret
09DE            655   TimeSoakNotOverflow:;=====================Soak time no overflow==============================================
09DE F56C       656            mov time_soak, a
09E0 C0E0       657            push acc
09E2 7405       657            mov a, #5
09E4 14         657            dec a
09E5 1201D6     657            lcall ?Set_Cursor_1 ; Select column and row
09E8 D0E0       657            pop acc
09EA 856C36     658            mov x+0, Time_Soak + 0
09ED 753700     659            mov x+1, #0
09F0 753800     660            mov x+2, #0
09F3 753900     661            mov x+3, #0
09F6 120252     662            lcall hex2bcd
09F9 C000       663            push ar0
09FB A83F       663            mov r0, bcd+1
09FD 1201DB     663            lcall ?Display_BCD
0A00 D000       663            pop ar0
0A02 C0E0       664            push acc
0A04 7407       664            mov a, #7
0A06 14         664            dec a
0A07 1201D6     664            lcall ?Set_Cursor_1 ; Select column and row
0A0A D0E0       664            pop acc
0A0C C000       665            push ar0
0A0E A83E       665            mov r0, bcd
0A10 1201DB     665            lcall ?Display_BCD
0A13 D000       665            pop ar0
0A15 22         666            ret
0A16            667   TempReflowAdjust:;=====================Reflow Temp adjusment=============================================
0A16 C002       668            push AR2
0A18 7A32       668            mov R2, #50
0A1A 120145     668            lcall ?Wait_Milli_Seconds
0A1D D002       668            pop AR2
0A1F E56D       669            mov a, Temp_Refl
0A21 2401       670            add a, #0x01
0A23 B4E630     671            cjne a, #0xe6, TempReflowNotOverflow ;0xe6 = 230 TBC POSSIBLY
0A26 756DD9     672            mov Temp_Refl, #0xd9 ;0xd9 = 217
0A29 C0E0       673            push acc
0A2B 740A       673            mov a, #10
0A2D 14         673            dec a
0A2E 1201D6     673            lcall ?Set_Cursor_1 ; Select column and row
0A31 D0E0       673            pop acc
0A33 856D36     674            mov x+0, Temp_Refl + 0
0A36 120252     675            lcall hex2bcd
0A39 C000       676            push ar0
0A3B A83F       676            mov r0, bcd+1
0A3D 1201DB     676            lcall ?Display_BCD
0A40 D000       676            pop ar0
0A42 C0E0       677            push acc
0A44 740C       677            mov a, #12
0A46 14         677            dec a
0A47 1201D6     677            lcall ?Set_Cursor_1 ; Select column and row
0A4A D0E0       677            pop acc
0A4C C000       678            push ar0
0A4E A83E       678            mov r0, bcd
0A50 1201DB     678            lcall ?Display_BCD
0A53 D000       678            pop ar0
0A55 22         679            ret
0A56            680   TempReflowNotOverflow:
0A56 F56D       681            mov temp_refl, a
0A58 C0E0       682            push acc
0A5A 740A       682            mov a, #10
0A5C 14         682            dec a
0A5D 1201D6     682            lcall ?Set_Cursor_1 ; Select column and row
0A60 D0E0       682            pop acc
0A62 856D36     683            mov x+0, Temp_Refl + 0
0A65 120252     684            lcall hex2bcd
0A68 C000       685            push ar0
0A6A A83F       685            mov r0, bcd+1
0A6C 1201DB     685            lcall ?Display_BCD
0A6F D000       685            pop ar0
0A71 C0E0       686            push acc
0A73 740C       686            mov a, #12
0A75 14         686            dec a
0A76 1201D6     686            lcall ?Set_Cursor_1 ; Select column and row
0A79 D0E0       686            pop acc
0A7B C000       687            push ar0
0A7D A83E       687            mov r0, bcd
0A7F 1201DB     687            lcall ?Display_BCD
0A82 D000       687            pop ar0
0A84 22         688            ret
0A85            689   TimeReflowAdjust:;=====================Reflow TIME adjusment=============================================
0A85 C002       690            push AR2
0A87 7A32       690            mov R2, #50
0A89 120145     690            lcall ?Wait_Milli_Seconds
0A8C D002       690            pop AR2
0A8E E56E       691            mov a, Time_Refl
0A90 2401       692            add a, #0x01
0A92 B44C1D     693            cjne a, #0x4c, TimeReflowNotOverflow ; 0x4c=76
0A95 756E2D     694            mov Time_Refl, #0x2d ;0x2d = 45
0A98 856E36     695            mov x+0, Time_Refl + 0
0A9B 120252     696            lcall hex2bcd
0A9E C0E0       697            push acc
0AA0 740F       697            mov a, #15
0AA2 14         697            dec a
0AA3 1201D6     697            lcall ?Set_Cursor_1 ; Select column and row
0AA6 D0E0       697            pop acc
0AA8 C000       698            push ar0
0AAA A83E       698            mov r0, bcd
0AAC 1201DB     698            lcall ?Display_BCD
0AAF D000       698            pop ar0
0AB1 22         699            ret
0AB2            700   TimeReflowNotOverflow:;=====================Soak time no overflow==============================================
0AB2 F56E       701            mov time_Refl, a
0AB4 856E36     702            mov x+0, Time_Refl + 0
0AB7 120252     703            lcall hex2bcd
0ABA C0E0       704            push acc
0ABC 740F       704            mov a, #15
0ABE 14         704            dec a
0ABF 1201D6     704            lcall ?Set_Cursor_1 ; Select column and row
0AC2 D0E0       704            pop acc
0AC4 C000       705            push ar0
0AC6 A83E       705            mov r0, bcd
0AC8 1201DB     705            lcall ?Display_BCD
0ACB D000       705            pop ar0
0ACD 22         706            ret
0ACE            707   
0ACE            708   end
