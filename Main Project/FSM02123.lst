0000              1   ; This program tests the LTC2308 avaliable in the newer version of the DE1-SoC board.
0000              2   ; Access to the input pins of the ADC is avalible at connector J15. Here is the top
0000              3   ; view of the connector:
0000              4   ;
0000              5   ; +--+
0000              6   ; |  | <-- Red power button
0000              7   ; +--+
0000              8   ;
0000              9   ; +-----+-----+
0000             10   ; + GND | IN7 |
0000             11   ; +-----+-----+
0000             12   ; + IN6 | IN5 |
0000             13   ; +-----+-----+
0000             14   ; + IN4 | IN3 |
0000             15   ; +-----+-----+
0000             16   ; + IN2 | IN1 |
0000             17   ; ------+-----+
0000             18   ; + IN0 | 5V  |
0000             19   ; +-----+-----+
0000             20   ;      J15
0000             21   ; 
0000             22   ; Displays the result using the 7-segment displays and also sends it via the serial port to PUTTy.
0000             23   ;
0000             24   ; (c) Jesus Calvino-Fraga 2019
0000             25   ;
                 27   $LIST
0000             29   
0000             30   ; Bits used to access the LTC2308
0000             31   LTC2308_MISO bit 0xF8 ; Read only bit
0000             32   LTC2308_MOSI bit 0xF9 ; Write only bit
0000             33   LTC2308_SCLK bit 0xFA ; Write only bit
0000             34   LTC2308_ENN  bit 0xFB ; Write only bit
0000             35   
0000             36   ;BUTTONS
0000             37   button1          equ P2.1
0000             38   button2          equ P2.2
0000             39   button3          equ P2.3
0000             40   button4          equ P2.4
0000             41   button5          equ P2.5
0000             42   ;STATES
0000             43   Select           equ 0
0000             44   RAMPTOSOAK       equ 1
0000             45   PREHEAT          equ 2
0000             46   RAMPTOPEAK       equ 3
0000             47   REFLOW           equ 4
0000             48   COOLING          equ 5
0000             49   
0000             50   CLK EQU 33333333
0000             51   BAUD EQU 57600
0000             52   TIMER_2_RELOAD EQU (65536-(CLK/(32*BAUD)))
0000             53   TIMER_0_1ms EQU (65536-(CLK/(12*1000)))
0000             54   
0000             55   ;;
0000             56   ;;
0000             57   ;; PUSH BUTTON DEFINITIONS
0000             58   ;;
0000             59   ;;
0000             60   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             61   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is 12 unlike the AT89LP51RC2 where is 1.
0000             62   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             63   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             64   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0000             65   
0000             66   
0000             67   ; Reset vector
0000             68   org 0x0000
0000 02062E      69       ljmp MainProgram
0003             70   
0003             71   ; External interrupt 0 vector (not used in this code)
0003             72   org 0x0003
0003 32          73            reti
0004             74   
0004             75   ; Timer/Counter 0 overflow interrupt vector
000B             76   org 0x000B
000B 0205A5      77            ljmp Timer0_ISR
000E             78   
000E             79   ; External interrupt 1 vector (not used in this code)
0013             80   org 0x0013
0013 32          81            reti
0014             82   
0014             83   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             84   org 0x001B
001B 32          85            reti
001C             86   
001C             87   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             88   org 0x0023 
0023 32          89            reti
0024             90            
0024             91   ; Timer/Counter 2 overflow interrupt vector
002B             92   org 0x002B
002B 0205C7      93            ljmp Timer2_ISR
002E             94            
002E             95   SOUND_OUT     equ P1.0
002E             96   UPDOWN        equ SWA.0
002E             97   
002E             98   ; Reset vector
002E             99   
002E            100   
002E            101   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            102   dseg at 0x30
0030            103   Count1ms:     ds 2 ; Used to determine when half second has passed
0032            104   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            105   Seconds:  ds 1
0034            106   Minutes: ds 1
0035            107   pwm: ds 1
0036            108   x:       ds 4
003A            109   y:       ds 4
003E            110   bcd:     ds 5
0043            111   buffer: ds 30
0061            112   vResult:         ds 2
0063            113   cTemp:   ds 2
0065            114   hTemp:   ds 3
0068            115   tTemp:   ds 3
006B            116   ;FSM Variables
006B            117   temp_soak: ds 1
006C            118   time_soak: ds 1
006D            119   temp_refl: ds 1
006E            120   time_refl: ds 1
006F            121   temp: ds 1
0070            122   timer: ds 1
0071            123   state: ds 1
0072            124   sec: ds 1
0073            125   MyHope: ds 1
0074            126   WorkingTime: ds 1
0075            127   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0075            128   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            129   bseg
0000            130   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            131   PwmFlag: dbit 1
0002            132   mf: dbit 1
0003            133   
002E            134   cseg     
002E            135   BJTBase equ P0.0
002E            136   ELCD_RS equ P1.2
002E            137   ELCD_RW equ P1.3
002E            138   ELCD_E  equ P1.4
002E            139   ELCD_D4 equ P1.5
002E            140   ELCD_D5 equ P1.6
002E            141   ELCD_D6 equ P1.7
002E            142   ELCD_D7 equ P0.6
002E            143   
002E            144   CE_ADC   EQU P0.2
002E            145   MY_MOSI EQU P0.0
002E            146   MY_MISO EQU P2.0
002E            147   MY_SCLK EQU P0.1
002E            148   
002E            149   PWMout equ P0.3
002E            150   
                625   $LIST
                153   $LIST
0541            155   
0541 0D0A4C54   156   InitialString: db '\r\nLTC2308 test program\r\n', 0
     43323330
     38207465
     73742070
     726F6772
     616D0D0A
     00
055A 48656C6F   157   MyString: db 'Helo213qwq', 0
     32313371
     777100
0565            158   Hello_World: ;indent to separate numbers in the putty
0565 0D0A00     159       DB  '\r','\n', 0
0568            160   
0568            161   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0568            162   T_7seg:
0568 40792430   163       DB 40H, 79H, 24H, 30H, 19H, 12H, 02H, 78H, 00H, 10H
     19120278
     0010
0572            164   
0572            165   ; Display the 4-digit bcd stored in [R3,R2] using the 7-segment displays
0572            166   
0572            167   
0572            168   ; Send a 4-digit BCD number stored in [R3,R2] to the serial port         
0572            169   
0572            170            
0572            171   ; Wait 1 millisecond using Timer 0
0572            172   Wait1ms:
0572 C28C       173            clr     TR0
0574 74F0       174            mov     a,#0xF0
0576 5589       175            anl     a,TMOD
0578 4401       176            orl     a,#0x01
057A F589       177            mov     TMOD,a
057C 758CF5     178            mov     TH0, #high(TIMER_0_1ms)
057F 758A27     179            mov     TL0, #low(TIMER_0_1ms)
0582 C28D       180            clr     TF0
0584 D28C       181            setb TR0
0586 308DFD     182            jnb     TF0,$
0589 C28C       183            clr     TR0
058B 22         184            ret
058C            185            
058C            186   ; Wait R2 milliseconds
058C            187   MyDelay:
058C 120572     188            lcall Wait1ms
058F DAFB       189       djnz R2, MyDelay
0591 22         190            ret
0592            191            
0592            192   Timer0_Init:
0592 E589       193            mov a, TMOD
0594 54F0       194            anl a, #0xf0 ; Clear the bits for timer 0
0596 4401       195            orl a, #0x01 ; Configure timer 0 as 16-timer
0598 F589       196            mov TMOD, a
059A 758CFD     197            mov TH0, #high(TIMER0_RELOAD)
059D 758A5A     198            mov TL0, #low(TIMER0_RELOAD)
05A0            199            ; Enable the timer and interrupts
05A0 D2A9       200       setb ET0  ; Enable timer 0 interrupt
05A2 D28C       201       setb TR0  ; Start timer 0
05A4 22         202            ret
05A5            203   
05A5            204   ;---------------------------------;
05A5            205   ; ISR for timer 0.  Set to execute;
05A5            206   ; every 1/4096Hz to generate a    ;
05A5            207   ; 2048 Hz square wave at pin P3.7 ;
05A5            208   ;---------------------------------;
05A5            209   Timer0_ISR:
05A5            210   ;        clr TF0  ; According to the data sheet this is done for us already.
05A5 758CFD     211            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
05A8 758A5A     212            mov TL0, #low(TIMER0_RELOAD)
05AB            213   
05AB            214            
05AB 32         215            reti
05AC            216   
05AC            217   ;---------------------------------;
05AC            218   ; Routine to initialize the ISR   ;
05AC            219   ; for timer 2                     ;
05AC            220   ;---------------------------------;
05AC            221   
05AC            222   Timer2_Init:
05AC 75C800     223            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
05AF 75CDF5     224            mov TH2, #high(TIMER2_RELOAD)
05B2 75CC27     225            mov TL2, #low(TIMER2_RELOAD)
05B5            226            ; Set the reload value
05B5 75CBF5     227            mov RCAP2H, #high(TIMER2_RELOAD)
05B8 75CA27     228            mov RCAP2L, #low(TIMER2_RELOAD)
05BB B2E9       229            cpl LEDRA.1
05BD            230            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
05BD E4         231            clr a
05BE F530       232            mov Count1ms+0, a
05C0 F531       233            mov Count1ms+1, a
05C2            234            ; Enable the timer and interrupts
05C2 D2AD       235       setb ET2  ; Enable timer 2 interrupt
05C4 D2CA       236       setb TR2  ; Enable timer 2
05C6 22         237            ret
05C7            238   
05C7            239   ;---------------------------------;
05C7            240   ; ISR for timer 2                 ;
05C7            241   ;---------------------------------;
05C7            242   Timer2_ISR:
05C7 C2CF       243            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
05C9            244   ;        cpl P1.1 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
05C9            245            
05C9            246            ; The two registers used in the ISR must be saved in the stack
05C9 C0E0       247            push acc
05CB C0D0       248            push psw
05CD            249            
05CD            250            ; Increment the 16-bit one mili second counter
05CD 0530       251            inc Count1ms+0    ; Increment the low 8-bits first
05CF E530       252            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05D1            253   
05D1 7002       254            jnz Inc_Done
05D3 0531       255            inc Count1ms+1
05D5            256   
05D5            257   Inc_Done:;===========================================ISR MAIN=============================================
05D5            258            ; Check if half second has passed
05D5 E530       259            mov a, Count1ms+0
05D7 B4F44F     260            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
05DA E531       261            mov a, Count1ms+1
05DC B4014A     262            cjne a, #high(500), Timer2_ISR_done
05DF            263            
05DF            264            ; 500 milliseconds have passed.  Set a flag so the main program knows
05DF D200       265            setb half_seconds_flag ; Let the main program know half second had passed
05E1            266            ; Toggle LEDR0 so it blinks
05E1            267            ;=====================Timer 0 controls============================================
05E1            268            ;cpl LEDRA.0
05E1            269            ;lcall pwmmodule
05E1            270   ;        cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
05E1            271            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
05E1            272            ;==================================================================================================
05E1 E4         273            clr a
05E2            274            ;=====================Display=============================================
05E2            275   ;        mov x+0, Temp_soak+0
05E2            276   ;        mov x+1, #0
05E2            277   ;        mov x+2, #0
05E2            278   ;        mov x+3, #0
05E2            279   ;
05E2            280   ;        Load_Y(1)
05E2            281   ;        lcall mul32
05E2            282   ;        lcall hex2bcd
05E2            283   
05E2            284   ;        Send_BCD(bcd+1)
05E2            285            
05E2 C0E0       286            push acc
05E4 7401       286            mov a, #1
05E6 14         286            dec a
05E7 1201D4     286            lcall ?Set_Cursor_2 ; Select column and row
05EA D0E0       286            pop acc
05EC C000       287            push ar0
05EE A834       287            mov r0, minutes
05F0 1201DB     287            lcall ?Display_BCD
05F3 D000       287            pop ar0
05F5 C0E0       288            push acc
05F7 7404       288            mov a, #4
05F9 14         288            dec a
05FA 1201D4     288            lcall ?Set_Cursor_2 ; Select column and row
05FD D0E0       288            pop acc
05FF            289   ;        Send_BCD(bcd)
05FF C000       290            push ar0
0601 A833       290            mov r0, seconds
0603 1201DB     290            lcall ?Display_BCD
0606 D000       290            pop ar0
0608            291   ;        mov DPTR, #Hello_World
0608            292   ;        lcall SendString
0608            293   ;==============================================================================================
0608 F530       294            mov Count1ms+0, a
060A F531       295            mov Count1ms+1, a
060C            296            ; Increment the BCD counter
060C            297            
060C E573       298            mov a, MyHope
060E 2401       299            add a, #1
0610 F573       300            mov MyHope, a
0612            301   
0612            302            ;mov x + 0, WorkingTime + 0
0612            303            ;mov x + 1, #0
0612            304            ;mov x + 2, #0
0612            305            ;mov x + 3, #0
0612            306            
0612            307            ;mov y + 0, pwm + 0
0612            308            ;mov y + 1, pwm + 1
0612            309            ;mov y + 2, #0
0612            310            ;mov y + 3, #0
0612            311            
0612            312            ;lcall mul32
0612            313            ;Load_Y(100)
0612            314            ;lcall div32
0612            315            ;mov    Workingtime + 0, x + 0
0612            316            
0612 1207D4     317            lcall ReadTemperature
0615 E533       318            mov a, Seconds
0617            319   ;        jb UPDOWN, Timer2_ISR_decrement
0617 2401       320            add a, #0x01
0619            321            ;sjmp Timer2_ISR_da
0619            322   ;Timer2_ISR_decrement:;=====================ISR DECREMENT=============================================
0619            323   ;        add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.    
0619            324            
0619            325            
0619            326   Timer2_ISR_da:
0619 D4         327            da a ; Decimal adjust instruction.  Check datasheet for more details!   
061A F533       328            mov seconds, a
061C            329   
061C B4600A     330            cjne a, #0x60, Timer2_ISR_done ;if seconds are not 60, go to ISR_done
061F 753300     331            mov Seconds, #0x0 ;reset seconds to 0
0622 E534       332            mov a, Minutes ; set a to previous minutes
0624 2401       333            add a, #0x01 ;add one to obtain current minutes
0626 D4         334            da a ;makes formatting nice 
0627 F534       335            mov Minutes, a ;put updated minutes into the counter
0629            336   ;        sjmp Timer2_ISR_M_aadjust
0629            337            
0629            338   Timer2_ISR_done:
0629 D0D0       339            pop psw
062B D0E0       340            pop acc
062D 32         341            reti
062E            342            
062E            343   
062E            344   MainProgram:;============================MAIN===========================================================
062E 75817F     345       mov sp, #0x7f
0631 120592     346       lcall Timer0_Init
0634 1205AC     347       lcall Timer2_Init
0637 120095     348       lcall Initialize_LEDs
063A 12007E     349       lcall Initialize_Serial_Port
063D 12009C     350       lcall Initialize_ADC
0640 120592     351       lcall Timer0_Init
0643 1205AC     352       lcall Timer2_Init
0646 120229     353       lcall INIT_SPI
0649            354   ;FSM Variables  ==================
0649 E4         355            clr a
064A F56B       356            mov temp_soak, a
064C 756B1E     357       mov temp_soak, #0x1e ; Will remain in hex, 0x82 is orig value else is for debugging
064F 756C3C     358            mov time_soak, #0x3c     ;HAS TO BE IN HEX only convert to bcd for display!
0652 756D23     359            mov temp_refl, #0x23 ;230 0xdc is original, else debug
0655 756E41     360            mov time_refl, #0x41 ;65
0658            361            
0658 756F19     362            mov temp, #25
065B 757000     363            mov timer, #0x00
065E 757100     364            mov state, #0x00
0661 757200     365            mov sec, #0x00
0664 753400     366            mov minutes, #0
0667 750200     367            mov mf, #0
066A 757300     368            mov MyHope, #0
066D 757400     369            mov WorkingTime, #0x00
0670            370   ;========================
0670            371     ;  lcall InitSerialPort
0670            372            ;clr TR0
0670 759AFF     373       mov P0MOD, #11111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
0673            374       ; We use pins P1.0 and P1.1 as outputs also.  Configure accordingly.
0673 759BFF     375       mov P1MOD, #11111111b ; P1.0 and P1.0 are outputs
0676 120194     376       lcall ELCD_4BIT
0679            377     ;  clr EX1
0679 D2AF       378       setb EA
067B            379   
067B            380   ;        Set_Cursor(1,1)
067B            381   ;        Send_Constant_String(#MyString)
067B B2EC       382            cpl LEDRA.4
067D D200       383            setb half_seconds_flag
067F 753350     384            mov Seconds, #0x50
0682 120870     385            lcall DisplayVariables
0685            386   forever:;======================================================FOREVER===========================================================
0685 E5E8       387            mov a, SWA ; read the channel to convert from the switches
0687 5407       388            anl a, #00000111B ; We need only the last three bits since there are only eight channels
0689 F5F0       389            mov b, a
068B 1200AC     390            lcall LTC2308_RW  ; Read the channel from the ADC
068E 120060     391            lcall hex2bcd16   ; Convert to bcd
0691            392   ;        lcall Display_BCD1 ; Display using the 7-segment displays
0691            393   ;        lcall SendNumber  ; Send to serial port
0691            394   ;        jnb BJTBase, pinpressed
0691 7AFA       395            mov R2, #250
0693            396            
0693 20F91C     397            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
0696 C002       398            push AR2
0698 7A32       398            mov R2, #50
069A 120145     398            lcall ?Wait_Milli_Seconds
069D D002       398            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit_DE1SoC.inc'
069F 20F910     399            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
06A2 30F9FD     400            jnb KEY.1, $    
06A5 C2CA       401            clr TR2 ; Stop timer 2
06A7 E4         402            clr a
06A8 F530       403            mov Count1ms+0, a
06AA F531       404            mov Count1ms+1, a
06AC            405            ; Now clear the BCD counter
06AC F532       406            mov BCD_counter, a
06AE D2CA       407            setb TR2    ; Start timer 2
06B0 8003       408            sjmp loop_b ; Display the new value
06B2            409   loop_a:;======================================================FOREVER================================================
06B2 3000D0     410            jnb half_seconds_flag, forever
06B5            411   loop_b:;======================================================FOREVER================================================
06B5 C200       412            clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
06B7 C0E0       413            push acc
06B9 740F       413            mov a, #15
06BB 14         413            dec a
06BC 1201D4     413            lcall ?Set_Cursor_2 ; Select column and row
06BF D0E0       413            pop acc     ; the place in the LCD where we want the BCD counter value
06C1 C000       414            push ar0
06C3 A871       414            mov r0, state
06C5 1201DB     414            lcall ?Display_BCD
06C8 D000       414            pop ar0
06CA            415   ;        cpl LEDRA.4
06CA            416   
06CA E571       417       mov a, state
06CC            418    ;=======================================================STATE 0========================================
06CC            419   ResetState:
06CC B40031     420            cjne a, #select, RampToSoakState
06CF            421   ;Display Time Soak
06CF 753400     422            mov minutes, #0                                 ;set timer to zero until state 1 is active
06D2 753300     423            mov seconds, #0
06D5 30A122     424            jnb button1, Pathnextstate
06D8 30A20B     425            jnb button2, PathTempSoakAdjust
06DB 30A30D     426            jnb button3, PathTimeSoakAdjust
06DE 30A414     427            jnb button4, PathTempReflowAdjust
06E1 30A50C     428            jnb button5, PathTimeReflowAdjust ; TimeReflowAdjust jump
06E4            429   
06E4 801A       430            sjmp RampToSoakState
06E6            431   PathTempSoakAdjust:
06E6 120917     432            lcall TempSoakAdjust
06E9 8012       433            sjmp SkipSetup1
06EB            434   PathTimeSoakAdjust:
06EB 120986     435            lcall TimeSoakAdjust
06EE 800D       436            sjmp SkipSetup1
06F0            437   PathTimeReflowAdjust: 
06F0 120A76     438            lcall TimeReflowAdjust
06F3 8008       439            sjmp SkipSetup1
06F5            440   PathTempReflowAdjust:
06F5 120A07     441            lcall TempReflowAdjust
06F8 8003       442            sjmp SkipSetup1
06FA            443   PathNextState:
06FA 0207A4     444            ljmp nextstate
06FD            445   SkipSetup1:;=====================CHANGE  OF STATES==============================================
06FD 020685     446            ljmp forever
0700            447   
0700            448            ;mov Seconds, #0x00
0700            449            ;mov minutes, #0
0700            450   RampToSoakState:         ;==============================STATE 1================================================
0700 B4012C     451            cjne a, #RampToSoak, PreHeatState
0703 753564     452            mov pwm, #0x64
0706 757405     453            mov WorkingTime, #0x05
0709            454            
0709            455     ;  mov sec, #0
0709            456    ;=============================Checking ih current temp has reaches soak temp==========================================   
0709 856536     457            mov x, hTemp
070C 753700     458            mov x+1, #0
070F 753800     459            mov x+2, #0
0712 753900     460            mov x+3, #0
0715            461   
0715 856B3A     462            mov y, temp_soak
0718 753B00     463            mov y+1, #0
071B 753C00     464            mov y+2, #0
071E 753D00     465            mov y+3, #0
0721 12035A     466            lcall x_lt_y
0724            467   ;====================================If its reached, move on to the next state, if not abort if 60 seconds passed=============
0724 30027D     468            jnb     mf, nextstate
0727 E534       469            mov a, Minutes
0729 B40175     470       cjne a, #0x01, SkipSetup
072C 0207C3     471       ljmp abort
072F            472   
072F            473   PreHeatState:;====================================================STATE 2===========================================
072F B4020E     474            cjne a, #PreHeat, RampToHeatState
0732 753514     475            mov pwm, #0x14
0735 757402     476            mov WorkingTime, #0x02
0738            477   ;        lcall pwmloop
0738 E573       478            mov a, MyHope
073A B56C64     479            cjne a, Time_Soak, SkipSetup
073D 1207A4     480            lcall nextstate
0740            481   RampToHeatState:;====================================================STATE 3===========================================
0740 B40326     482            cjne a, #RampToPeak, ReflowState
0743 753564     483            mov pwm, #0x64
0746 757405     484            mov WorkingTime, #0x05
0749            485   ;        lcall pwmloop
0749 856536     486            mov x, hTemp
074C 753700     487            mov x+1, #0
074F 753800     488            mov x+2, #0
0752 753900     489            mov x+3, #0
0755            490   
0755 856D3A     491            mov y, temp_refl
0758 753B00     492            mov y+1, #0
075B 753C00     493            mov y+2, #0
075E 753D00     494            mov y+3, #0
0761 12035A     495            lcall x_lt_y
0764            496                            
0764 30023D     497            jnb     mf, nextstate
0767 8038       498            sjmp SkipSetup
0769            499   ReflowState:
0769 B4040E     500            cjne a, #Reflow, CoolingState
076C 753514     501            mov pwm, #0x14
076F 757405     502            mov WorkingTime, #0x05
0772            503            ;lcall pwmloop
0772 E573       504            mov a, MyHope
0774 B56E2A     505            cjne a, Time_Refl, SkipSetup
0777 1207A4     506            lcall nextstate
077A            507   CoolingState:
077A B40524     508            cjne a, #Cooling, SkipSetup
077D 753500     509            mov pwm, #0
0780 757400     510            mov WorkingTime, #0x00
0783            511   ;        lcall pwmloop
0783 856536     512            mov x, hTemp
0786 753700     513            mov x+1, #0
0789 753800     514            mov x+2, #0
078C 753900     515            mov x+3, #0
078F            516   
078F 753A20     517            mov y, #0x20
0792 753B00     518            mov y+1, #0
0795 753C00     519            mov y+2, #0
0798 753D00     520            mov y+3, #0
079B 12035A     521            lcall x_lt_y
079E            522                            
079E 200203     523            jb      mf, nextstate
07A1            524            
07A1            525   SkipSetup:;=====================CHANGE  OF STATES==============================================
07A1 020685     526            ljmp forever
07A4            527   nextstate: ;=====================CHANGE  OF STATES==============================================
07A4 C002       528            push AR2
07A6 7A32       528            mov R2, #50
07A8 120145     528            lcall ?Wait_Milli_Seconds
07AB D002       528            pop AR2
07AD 753300     529            mov seconds, #0
07B0 753400     530            mov minutes, #0
07B3 757300     531            mov MyHope, #0
07B6 E571       532            mov a, state
07B8 2401       533            add a, #1
07BA B40612     534            cjne a, #6, NoStateReset
07BD 757100     535            mov state, #0
07C0            536   ;        cpl LEDRA.7
07C0            537   
07C0 0207A1     538            ljmp SkipSetup
07C3            539   abort: ;=================================ABORT1=====================================================
07C3 757100     540            mov state, #0
07C6 753500     541            mov pwm, #0
07C9 757400     542            mov WorkingTime, #0x00
07CC            543   ;        lcall pwmloop
07CC 0207A1     544            ljmp SkipSetup
07CF            545   ;====================================================PATHS==(if ljmp is outside of bounds)==============================================
07CF            546   
07CF            547   NoStateReset:;=====================STATE OVERFLOW==============================================
07CF F571       548            mov state, a
07D1            549            ;cpl LEDRA.7
07D1 0207A1     550            ljmp SkipSetup  
07D4            551   
07D4            552   ReadTemperature: 
07D4            553   ;        Read_ADC_Channel(0)
07D4            554   ;        volt2ctemp(cTemp) 
07D4            555   ;        mov cTemp, #25
07D4 75F003     556            mov b, #3
07D7 1201F1     556            lcall _Read_ADC_Channel
07DA C000       557            push aR0
07DC A865       557            mov R0, hTemp
07DE 120509     557            lcall _volt2htemp
07E1 D000       557            pop aR0
07E3            558   ;        So In order to keep stuff in hex, Got to convert cTemp back from bcd to hex. NOT CONVERTING TO BCD IN THE FIRST PLACE DIDNOT WORK. GAVE 0
07E3            559   ;        mov bcd+0, cTemp+0
07E3 753E00     560            mov bcd, #0
07E6 753F00     561            mov bcd+1, #0
07E9 754000     562            mov bcd+2, #0
07EC 754100     563            mov bcd+3, #0
07EF 754200     564            mov bcd+4, #0
07F2 1202DB     565            lcall bcd2hex
07F5 853663     566            mov cTemp + 0, x + 0
07F8 853764     567            mov cTemp + 1, x + 1
07FB            568   ;======Adding cold junction temp=======================================================  
07FB E565       569            mov a, hTemp
07FD            570   ;        add a, cTemp
07FD F565       571            mov hTemp, a
07FF            572   ;======Since its in hex got to adjust to convert it to decimal=======(No longer interested in converting outside of display)================================================     
07FF E565       573            mov a, hTemp
0801 D4         574            da a
0802 F565       575            mov hTemp, a
0804            576    ;======Display=====================================================================================
0804            577   
0804            578            
0804 856536     579            mov x + 0, hTemp+ 0
0807 856637     580            mov x + 1, hTemp+1
080A 753800     581            mov x+2, #0
080D 753900     582            mov x+3, #0
0810 120252     583            lcall hex2bcd
0813 900565     584            mov DPTR, #Hello_World
0816 120247     585            lcall SendString
0819 C000       586            push ar0
081B A83F       586            mov r0, bcd+1
081D 120213     586            lcall ?Send_BCD
0820 D000       586            pop ar0
0822 C000       587            push ar0
0824 A83E       587            mov r0, bcd
0826 120213     587            lcall ?Send_BCD
0829 D000       587            pop ar0
082B C0E0       588            push acc
082D 7409       588            mov a, #9
082F 14         588            dec a
0830 1201D4     588            lcall ?Set_Cursor_2 ; Select column and row
0833 D0E0       588            pop acc
0835 C000       589            push ar0
0837 A83F       589            mov r0, bcd+1
0839 1201DB     589            lcall ?Display_BCD
083C D000       589            pop ar0
083E C0E0       590            push acc
0840 740B       590            mov a, #11
0842 14         590            dec a
0843 1201D4     590            lcall ?Set_Cursor_2 ; Select column and row
0846 D0E0       590            pop acc
0848 C000       591            push ar0
084A A83E       591            mov r0, bcd
084C 1201DB     591            lcall ?Display_BCD
084F D000       591            pop ar0
0851 900565     592            mov DPTR, #Hello_World
0854 120247     593            lcall SendString
0857 C000       594            push ar0
0859 A864       594            mov r0, cTemp+1
085B 120213     594            lcall ?Send_BCD
085E D000       594            pop ar0
0860 C000       595            push ar0
0862 A863       595            mov r0, cTemp
0864 120213     595            lcall ?Send_BCD
0867 D000       595            pop ar0
0869 900565     596            mov DPTR, #Hello_World
086C 120247     597            lcall SendString
086F 22         598   ret
0870            599       
0870            600   DisplayVariables:
0870 C0E0       601            push acc
0872 7405       601            mov a, #5
0874 14         601            dec a
0875 1201D6     601            lcall ?Set_Cursor_1 ; Select column and row
0878 D0E0       601            pop acc
087A 856C36     602            mov x+0, Time_Soak + 0
087D 753700     603            mov x+1, #0
0880 753800     604            mov x+2, #0
0883 753900     605            mov x+3, #0
0886 120252     606            lcall hex2bcd
0889 C000       607            push ar0
088B A83F       607            mov r0, bcd+1
088D 1201DB     607            lcall ?Display_BCD
0890 D000       607            pop ar0
0892 C0E0       608            push acc
0894 7407       608            mov a, #7
0896 14         608            dec a
0897 1201D6     608            lcall ?Set_Cursor_1 ; Select column and row
089A D0E0       608            pop acc
089C C000       609            push ar0
089E A83E       609            mov r0, bcd
08A0 1201DB     609            lcall ?Display_BCD
08A3 D000       609            pop ar0
08A5            610   ;Display Temp Soak       
08A5 C0E0       611            push acc
08A7 7400       611            mov a, #0
08A9 14         611            dec a
08AA 1201D6     611            lcall ?Set_Cursor_1 ; Select column and row
08AD D0E0       611            pop acc
08AF 856B36     612            mov x+0, Temp_Soak + 0
08B2 120252     613            lcall hex2bcd
08B5 C000       614            push ar0
08B7 A83F       614            mov r0, bcd+1
08B9 1201DB     614            lcall ?Display_BCD
08BC D000       614            pop ar0
08BE C0E0       615            push acc
08C0 7402       615            mov a, #2
08C2 14         615            dec a
08C3 1201D6     615            lcall ?Set_Cursor_1 ; Select column and row
08C6 D0E0       615            pop acc
08C8 C000       616            push ar0
08CA A83E       616            mov r0, bcd
08CC 1201DB     616            lcall ?Display_BCD
08CF D000       616            pop ar0
08D1            617   ;display time Reflow
08D1 856E36     618            mov x+0, Time_Refl + 0
08D4 120252     619            lcall hex2bcd
08D7 C0E0       620            push acc
08D9 740F       620            mov a, #15
08DB 14         620            dec a
08DC 1201D6     620            lcall ?Set_Cursor_1 ; Select column and row
08DF D0E0       620            pop acc
08E1 C000       621            push ar0
08E3 A83E       621            mov r0, bcd
08E5 1201DB     621            lcall ?Display_BCD
08E8 D000       621            pop ar0
08EA            622   ;display temp reflow
08EA C0E0       623            push acc
08EC 740A       623            mov a, #10
08EE 14         623            dec a
08EF 1201D6     623            lcall ?Set_Cursor_1 ; Select column and row
08F2 D0E0       623            pop acc
08F4 856D36     624            mov x+0, Temp_Refl + 0
08F7 120252     625            lcall hex2bcd
08FA C000       626            push ar0
08FC A83F       626            mov r0, bcd+1
08FE 1201DB     626            lcall ?Display_BCD
0901 D000       626            pop ar0
0903 C0E0       627            push acc
0905 740C       627            mov a, #12
0907 14         627            dec a
0908 1201D6     627            lcall ?Set_Cursor_1 ; Select column and row
090B D0E0       627            pop acc
090D C000       628            push ar0
090F A83E       628            mov r0, bcd
0911 1201DB     628            lcall ?Display_BCD
0914 D000       628            pop ar0
0916 22         629            ret
0917            630            
0917            631   TempSoakAdjust:;=====================Soak Temperature adjustment==============================================
0917 C002       632            push AR2
0919 7A32       632            mov R2, #50
091B 120145     632            lcall ?Wait_Milli_Seconds
091E D002       632            pop AR2;
0920 E56B       633            mov a, temp_soak
0922 2401       634            add a, #0x01
0924            635            ;cpl LEDRA.6
0924 B4AB30     636            cjne a, #0xab, TempSoakNotOverflow ;0xab = 171
0927 756B82     637            mov temp_soak, #0x82 ;0x82 = 130
092A C0E0       638            push acc
092C 7400       638            mov a, #0
092E 14         638            dec a
092F 1201D6     638            lcall ?Set_Cursor_1 ; Select column and row
0932 D0E0       638            pop acc
0934 856B36     639            mov x+0, Temp_Soak + 0
0937 120252     640            lcall hex2bcd
093A C000       641            push ar0
093C A83F       641            mov r0, bcd+1
093E 1201DB     641            lcall ?Display_BCD
0941 D000       641            pop ar0
0943 C0E0       642            push acc
0945 7402       642            mov a, #2
0947 14         642            dec a
0948 1201D6     642            lcall ?Set_Cursor_1 ; Select column and row
094B D0E0       642            pop acc
094D C000       643            push ar0
094F A83E       643            mov r0, bcd
0951 1201DB     643            lcall ?Display_BCD
0954 D000       643            pop ar0
0956 22         644            ret
0957            645            ;ljmp SkipSetup
0957            646   TempSoakNotOverflow:;=====================Soak Temperature no overflow==============================================
0957 F56B       647            mov temp_soak, a
0959 C0E0       648            push acc
095B 7400       648            mov a, #0
095D 14         648            dec a
095E 1201D6     648            lcall ?Set_Cursor_1 ; Select column and row
0961 D0E0       648            pop acc
0963 856B36     649            mov x+0, Temp_Soak + 0
0966 120252     650            lcall hex2bcd
0969 C000       651            push ar0
096B A83F       651            mov r0, bcd+1
096D 1201DB     651            lcall ?Display_BCD
0970 D000       651            pop ar0
0972 C0E0       652            push acc
0974 7402       652            mov a, #2
0976 14         652            dec a
0977 1201D6     652            lcall ?Set_Cursor_1 ; Select column and row
097A D0E0       652            pop acc
097C C000       653            push ar0
097E A83E       653            mov r0, bcd
0980 1201DB     653            lcall ?Display_BCD
0983 D000       653            pop ar0
0985 22         654       ret
0986            655   TimeSoakAdjust:;=====================Soak time Adjustment==============================================
0986 C002       656            push AR2
0988 7A32       656            mov R2, #50
098A 120145     656            lcall ?Wait_Milli_Seconds
098D D002       656            pop AR2
098F E56C       657            mov a, Time_Soak
0991 2401       658            add a, #0x01
0993 B47939     659            cjne a, #0x79, TimeSoakNotOverflow;0x79=121
0996 756C3C     660            mov time_soak, #0x3c ;0x3c=60
0999 C0E0       661            push acc
099B 7405       661            mov a, #5
099D 14         661            dec a
099E 1201D6     661            lcall ?Set_Cursor_1 ; Select column and row
09A1 D0E0       661            pop acc
09A3 856C36     662            mov x+0, Time_Soak + 0
09A6 753700     663            mov x+1, #0
09A9 753800     664            mov x+2, #0
09AC 753900     665            mov x+3, #0
09AF 120252     666            lcall hex2bcd
09B2 C000       667            push ar0
09B4 A83F       667            mov r0, bcd+1
09B6 1201DB     667            lcall ?Display_BCD
09B9 D000       667            pop ar0
09BB C0E0       668            push acc
09BD 7407       668            mov a, #7
09BF 14         668            dec a
09C0 1201D6     668            lcall ?Set_Cursor_1 ; Select column and row
09C3 D0E0       668            pop acc
09C5 C000       669            push ar0
09C7 A83E       669            mov r0, bcd
09C9 1201DB     669            lcall ?Display_BCD
09CC D000       669            pop ar0
09CE 22         670            ret
09CF            671   TimeSoakNotOverflow:;=====================Soak time no overflow==============================================
09CF F56C       672            mov time_soak, a
09D1 C0E0       673            push acc
09D3 7405       673            mov a, #5
09D5 14         673            dec a
09D6 1201D6     673            lcall ?Set_Cursor_1 ; Select column and row
09D9 D0E0       673            pop acc
09DB 856C36     674            mov x+0, Time_Soak + 0
09DE 753700     675            mov x+1, #0
09E1 753800     676            mov x+2, #0
09E4 753900     677            mov x+3, #0
09E7 120252     678            lcall hex2bcd
09EA C000       679            push ar0
09EC A83F       679            mov r0, bcd+1
09EE 1201DB     679            lcall ?Display_BCD
09F1 D000       679            pop ar0
09F3 C0E0       680            push acc
09F5 7407       680            mov a, #7
09F7 14         680            dec a
09F8 1201D6     680            lcall ?Set_Cursor_1 ; Select column and row
09FB D0E0       680            pop acc
09FD C000       681            push ar0
09FF A83E       681            mov r0, bcd
0A01 1201DB     681            lcall ?Display_BCD
0A04 D000       681            pop ar0
0A06 22         682            ret
0A07            683   TempReflowAdjust:;=====================Reflow Temp adjusment=============================================
0A07 C002       684            push AR2
0A09 7A32       684            mov R2, #50
0A0B 120145     684            lcall ?Wait_Milli_Seconds
0A0E D002       684            pop AR2
0A10 E56D       685            mov a, Temp_Refl
0A12 2401       686            add a, #0x01
0A14 B4E630     687            cjne a, #0xe6, TempReflowNotOverflow ;0xe6 = 230 TBC POSSIBLY
0A17 756DD9     688            mov Temp_Refl, #0xd9 ;0xd9 = 217
0A1A C0E0       689            push acc
0A1C 740A       689            mov a, #10
0A1E 14         689            dec a
0A1F 1201D6     689            lcall ?Set_Cursor_1 ; Select column and row
0A22 D0E0       689            pop acc
0A24 856D36     690            mov x+0, Temp_Refl + 0
0A27 120252     691            lcall hex2bcd
0A2A C000       692            push ar0
0A2C A83F       692            mov r0, bcd+1
0A2E 1201DB     692            lcall ?Display_BCD
0A31 D000       692            pop ar0
0A33 C0E0       693            push acc
0A35 740C       693            mov a, #12
0A37 14         693            dec a
0A38 1201D6     693            lcall ?Set_Cursor_1 ; Select column and row
0A3B D0E0       693            pop acc
0A3D C000       694            push ar0
0A3F A83E       694            mov r0, bcd
0A41 1201DB     694            lcall ?Display_BCD
0A44 D000       694            pop ar0
0A46 22         695            ret
0A47            696   TempReflowNotOverflow:
0A47 F56D       697            mov temp_refl, a
0A49 C0E0       698            push acc
0A4B 740A       698            mov a, #10
0A4D 14         698            dec a
0A4E 1201D6     698            lcall ?Set_Cursor_1 ; Select column and row
0A51 D0E0       698            pop acc
0A53 856D36     699            mov x+0, Temp_Refl + 0
0A56 120252     700            lcall hex2bcd
0A59 C000       701            push ar0
0A5B A83F       701            mov r0, bcd+1
0A5D 1201DB     701            lcall ?Display_BCD
0A60 D000       701            pop ar0
0A62 C0E0       702            push acc
0A64 740C       702            mov a, #12
0A66 14         702            dec a
0A67 1201D6     702            lcall ?Set_Cursor_1 ; Select column and row
0A6A D0E0       702            pop acc
0A6C C000       703            push ar0
0A6E A83E       703            mov r0, bcd
0A70 1201DB     703            lcall ?Display_BCD
0A73 D000       703            pop ar0
0A75 22         704            ret
0A76            705   TimeReflowAdjust:;=====================Reflow TIME adjusment=============================================
0A76 C002       706            push AR2
0A78 7A32       706            mov R2, #50
0A7A 120145     706            lcall ?Wait_Milli_Seconds
0A7D D002       706            pop AR2
0A7F E56E       707            mov a, Time_Refl
0A81 2401       708            add a, #0x01
0A83 B44C1D     709            cjne a, #0x4c, TimeReflowNotOverflow ; 0x4c=76
0A86 756E2D     710            mov Time_Refl, #0x2d ;0x2d = 45
0A89 856E36     711            mov x+0, Time_Refl + 0
0A8C 120252     712            lcall hex2bcd
0A8F C0E0       713            push acc
0A91 740F       713            mov a, #15
0A93 14         713            dec a
0A94 1201D6     713            lcall ?Set_Cursor_1 ; Select column and row
0A97 D0E0       713            pop acc
0A99 C000       714            push ar0
0A9B A83E       714            mov r0, bcd
0A9D 1201DB     714            lcall ?Display_BCD
0AA0 D000       714            pop ar0
0AA2 22         715            ret
0AA3            716   TimeReflowNotOverflow:;=====================Soak time no overflow==============================================
0AA3 F56E       717            mov time_Refl, a
0AA5 856E36     718            mov x+0, Time_Refl + 0
0AA8 120252     719            lcall hex2bcd
0AAB C0E0       720            push acc
0AAD 740F       720            mov a, #15
0AAF 14         720            dec a
0AB0 1201D6     720            lcall ?Set_Cursor_1 ; Select column and row
0AB3 D0E0       720            pop acc
0AB5 C000       721            push ar0
0AB7 A83E       721            mov r0, bcd
0AB9 1201DB     721            lcall ?Display_BCD
0ABC D000       721            pop ar0
0ABE 22         722            ret
0ABF            723   
0ABF            724   
0ABF            725   PWMmodule:
0ABF E572       726            mov a, sec
0AC1            727   ;        
0AC1 B40535     728            cjne a, #5, DontReset
0AC4 757200     729            mov sec, #0
0AC7            730   BackUp:  
0AC7            731   ;        mov a, sec
0AC7 857236     732            mov x, sec
0ACA 753700     733            mov x+1, #0
0ACD 753800     734            mov x+2, #0
0AD0 753900     735            mov x+3, #0
0AD3            736   
0AD3 85743A     737            mov y, WorkingTime
0AD6 753B00     738            mov y+1, #0
0AD9 753C00     739            mov y+2, #0
0ADC 753D00     740            mov y+3, #0
0ADF 1203C2     741            lcall x_lteq_y
0AE2            742   ;====================================If its reached, move on to the next state, if not abort if 60 seconds passed=============
0AE2 200205     743            jb      mf, SetPwmFlagOn
0AE5 E4         744            clr a
0AE6 F501       745            mov PWMFlag, a
0AE8            746            
0AE8            747   ;        cpl SOUND_OUT ; Connect speaker to P3.7!
0AE8 8002       748            sjmp Power
0AEA            749   SetPwmFlagOn:
0AEA            750   
0AEA D201       751            setb PWMFlag
0AEC            752   Power:   
0AEC 2401       753            add a, #1
0AEE E501       754            mov a, PWMFlag
0AF0 B40003     755            cjne a, #0, TurnITON
0AF3 C283       756            clr PWMout
0AF5            757   
0AF5 22         758            ret
0AF6            759            
0AF6            760   TurnItOn:
0AF6 D283       761            setb PWMout
0AF8 22         762            ret
0AF9            763            
0AF9            764   DontReset:
0AF9 F572       765            mov sec, a
0AFB 80CA       766            sjmp BackUp
0AFD            767            
0AFD            768   en
