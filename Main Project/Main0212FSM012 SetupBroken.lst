0000              1   ; This program tests the LTC2308 avaliable in the newer version of the DE1-SoC board.
0000              2   ; Access to the input pins of the ADC is avalible at connector J15. Here is the top
0000              3   ; view of the connector:
0000              4   ;
0000              5   ; +--+
0000              6   ; |  | <-- Red power button
0000              7   ; +--+
0000              8   ;
0000              9   ; +-----+-----+
0000             10   ; + GND | IN7 |
0000             11   ; +-----+-----+
0000             12   ; + IN6 | IN5 |
0000             13   ; +-----+-----+
0000             14   ; + IN4 | IN3 |
0000             15   ; +-----+-----+
0000             16   ; + IN2 | IN1 |
0000             17   ; ------+-----+
0000             18   ; + IN0 | 5V  |
0000             19   ; +-----+-----+
0000             20   ;      J15
0000             21   ; 
0000             22   ; Displays the result using the 7-segment displays and also sends it via the serial port to PUTTy.
0000             23   ;
0000             24   ; (c) Jesus Calvino-Fraga 2019
0000             25   ;
                 27   $LIST
0000             29   
0000             30   ; Bits used to access the LTC2308
0000             31   LTC2308_MISO bit 0xF8 ; Read only bit
0000             32   LTC2308_MOSI bit 0xF9 ; Write only bit
0000             33   LTC2308_SCLK bit 0xFA ; Write only bit
0000             34   LTC2308_ENN  bit 0xFB ; Write only bit
0000             35   
0000             36   ;BUTTONS
0000             37   button1          equ P2.1
0000             38   button2          equ P2.2
0000             39   button3          equ P2.3
0000             40   button4          equ P2.4
0000             41   button5          equ P2.5
0000             42   ;STATES
0000             43   Select           equ 0
0000             44   RAMPTOSOAK       equ 1
0000             45   PREHEAT          equ 2
0000             46   RAMPTOPEAK       equ 3
0000             47   REFLOW           equ 4
0000             48   COOLING          equ 5
0000             49   
0000             50   CLK EQU 33333333
0000             51   BAUD EQU 57600
0000             52   TIMER_2_RELOAD EQU (65536-(CLK/(32*BAUD)))
0000             53   TIMER_0_1ms EQU (65536-(CLK/(12*1000)))
0000             54   
0000             55   ;;
0000             56   ;;
0000             57   ;; PUSH BUTTON DEFINITIONS
0000             58   ;;
0000             59   ;;
0000             60   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             61   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is 12 unlike the AT89LP51RC2 where is 1.
0000             62   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             63   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             64   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0000             65   
0000             66   
0000             67   ; Reset vector
0000             68   org 0x0000
0000 02062E      69       ljmp MainProgram
0003             70   
0003             71   ; External interrupt 0 vector (not used in this code)
0003             72   org 0x0003
0003 32          73            reti
0004             74   
0004             75   ; Timer/Counter 0 overflow interrupt vector
000B             76   org 0x000B
000B 0205A5      77            ljmp Timer0_ISR
000E             78   
000E             79   ; External interrupt 1 vector (not used in this code)
0013             80   org 0x0013
0013 32          81            reti
0014             82   
0014             83   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             84   org 0x001B
001B 32          85            reti
001C             86   
001C             87   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             88   org 0x0023 
0023 32          89            reti
0024             90            
0024             91   ; Timer/Counter 2 overflow interrupt vector
002B             92   org 0x002B
002B 0205C5      93            ljmp Timer2_ISR
002E             94            
002E             95   SOUND_OUT     equ P1.0
002E             96   UPDOWN        equ SWA.0
002E             97   
002E             98   ; Reset vector
002E             99   
002E            100   
002E            101   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            102   dseg at 0x30
0030            103   Count1ms:     ds 2 ; Used to determine when half second has passed
0032            104   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            105   Seconds:  ds 1
0034            106   Minutes: ds 1
0035            107   pwm: ds 1
0036            108   x:       ds 4
003A            109   y:       ds 4
003E            110   bcd:     ds 5
0043            111   buffer: ds 30
0061            112   vResult:         ds 2
0063            113   cTemp:   ds 2
0065            114   hTemp:   ds 3
0068            115   tTemp:   ds 3
006B            116   ;FSM Variables
006B            117   temp_soak: ds 1
006C            118   time_soak: ds 1
006D            119   temp_refl: ds 1
006E            120   time_refl: ds 1
006F            121   temp: ds 1
0070            122   timer: ds 1
0071            123   state: ds 1
0072            124   sec: ds 1
0073            125   MyHope: ds 1
0074            126   MyHope2: ds 1
0075            127   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0075            128   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            129   bseg
0000            130   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            131   mf: dbit 1
0002            132   
002E            133   cseg     
002E            134   BJTBase equ P0.0
002E            135   ELCD_RS equ P1.2
002E            136   ELCD_RW equ P1.3
002E            137   ELCD_E  equ P1.4
002E            138   ELCD_D4 equ P1.5
002E            139   ELCD_D5 equ P1.6
002E            140   ELCD_D6 equ P1.7
002E            141   ELCD_D7 equ P0.6
002E            142   
002E            143   CE_ADC   EQU P0.2
002E            144   MY_MOSI EQU P0.0
002E            145   MY_MISO EQU P2.0
002E            146   MY_SCLK EQU P0.1
002E            147   
002E            148   PWMout equ P0.3
002E            149   
                622   $LIST
                152   $LIST
0541            154   
0541 0D0A4C54   155   InitialString: db '\r\nLTC2308 test program\r\n', 0
     43323330
     38207465
     73742070
     726F6772
     616D0D0A
     00
055A 48656C6F   156   MyString: db 'Helo213qwq', 0
     32313371
     777100
0565            157   Hello_World: ;indent to separate numbers in the putty
0565 0D0A00     158       DB  '\r','\n', 0
0568            159   
0568            160   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0568            161   T_7seg:
0568 40792430   162       DB 40H, 79H, 24H, 30H, 19H, 12H, 02H, 78H, 00H, 10H
     19120278
     0010
0572            163   
0572            164   ; Display the 4-digit bcd stored in [R3,R2] using the 7-segment displays
0572            165   
0572            166   
0572            167   ; Send a 4-digit BCD number stored in [R3,R2] to the serial port         
0572            168   
0572            169            
0572            170   ; Wait 1 millisecond using Timer 0
0572            171   Wait1ms:
0572 C28C       172            clr     TR0
0574 74F0       173            mov     a,#0xF0
0576 5589       174            anl     a,TMOD
0578 4401       175            orl     a,#0x01
057A F589       176            mov     TMOD,a
057C 758CF5     177            mov     TH0, #high(TIMER_0_1ms)
057F 758A27     178            mov     TL0, #low(TIMER_0_1ms)
0582 C28D       179            clr     TF0
0584 D28C       180            setb TR0
0586 308DFD     181            jnb     TF0,$
0589 C28C       182            clr     TR0
058B 22         183            ret
058C            184            
058C            185   ; Wait R2 milliseconds
058C            186   MyDelay:
058C 120572     187            lcall Wait1ms
058F DAFB       188       djnz R2, MyDelay
0591 22         189            ret
0592            190            
0592            191   Timer0_Init:
0592 E589       192            mov a, TMOD
0594 54F0       193            anl a, #0xf0 ; Clear the bits for timer 0
0596 4401       194            orl a, #0x01 ; Configure timer 0 as 16-timer
0598 F589       195            mov TMOD, a
059A 758CFD     196            mov TH0, #high(TIMER0_RELOAD)
059D 758A5A     197            mov TL0, #low(TIMER0_RELOAD)
05A0            198            ; Enable the timer and interrupts
05A0 D2A9       199       setb ET0  ; Enable timer 0 interrupt
05A2 D28C       200       setb TR0  ; Start timer 0
05A4 22         201            ret
05A5            202   
05A5            203   ;---------------------------------;
05A5            204   ; ISR for timer 0.  Set to execute;
05A5            205   ; every 1/4096Hz to generate a    ;
05A5            206   ; 2048 Hz square wave at pin P3.7 ;
05A5            207   ;---------------------------------;
05A5            208   Timer0_ISR:
05A5            209   ;        clr TF0  ; According to the data sheet this is done for us already.
05A5 758CFD     210            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
05A8 758A5A     211            mov TL0, #low(TIMER0_RELOAD)
05AB            212   ;        cpl SOUND_OUT ; Connect speaker to P3.7!
05AB 32         213            reti
05AC            214   
05AC            215   ;---------------------------------;
05AC            216   ; Routine to initialize the ISR   ;
05AC            217   ; for timer 2                     ;
05AC            218   ;---------------------------------;
05AC            219   Timer2_Init:
05AC 75C800     220            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
05AF 75CDF5     221            mov TH2, #high(TIMER2_RELOAD)
05B2 75CC27     222            mov TL2, #low(TIMER2_RELOAD)
05B5            223            ; Set the reload value
05B5 75CBF5     224            mov RCAP2H, #high(TIMER2_RELOAD)
05B8 75CA27     225            mov RCAP2L, #low(TIMER2_RELOAD)
05BB            226            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
05BB E4         227            clr a
05BC F530       228            mov Count1ms+0, a
05BE F531       229            mov Count1ms+1, a
05C0            230            ; Enable the timer and interrupts
05C0 D2AD       231       setb ET2  ; Enable timer 2 interrupt
05C2 D2CA       232       setb TR2  ; Enable timer 2
05C4 22         233            ret
05C5            234   
05C5            235   ;---------------------------------;
05C5            236   ; ISR for timer 2                 ;
05C5            237   ;---------------------------------;
05C5            238   Timer2_ISR:
05C5 C2CF       239            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
05C7            240   ;        cpl P1.1 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
05C7            241            
05C7            242            ; The two registers used in the ISR must be saved in the stack
05C7 C0E0       243            push acc
05C9 C0D0       244            push psw
05CB            245            
05CB            246            ; Increment the 16-bit one mili second counter
05CB 0530       247            inc Count1ms+0    ; Increment the low 8-bits first
05CD E530       248            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05CF 7002       249            jnz Inc_Done
05D1 0531       250            inc Count1ms+1
05D3            251   
05D3            252   Inc_Done:;===========================================ISR MAIN=============================================
05D3            253            ; Check if half second has passed
05D3 E530       254            mov a, Count1ms+0
05D5 B4F451     255            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
05D8 E531       256            mov a, Count1ms+1
05DA B4014C     257            cjne a, #high(500), Timer2_ISR_done
05DD            258            
05DD            259            ; 500 milliseconds have passed.  Set a flag so the main program knows
05DD D200       260            setb half_seconds_flag ; Let the main program know half second had passed
05DF            261            ; Toggle LEDR0 so it blinks
05DF            262            ;=====================Timer 0 controls============================================
05DF            263            ;cpl LEDRA.0
05DF B28C       264            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
05E1            265            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
05E1            266            ;==================================================================================================
05E1 E4         267            clr a
05E2            268            ;=====================Display=============================================
05E2            269   ;        mov x+0, Temp_soak+0
05E2            270   ;        mov x+1, #0
05E2            271   ;        mov x+2, #0
05E2            272   ;        mov x+3, #0
05E2            273   ;
05E2            274   ;        Load_Y(1)
05E2            275   ;        lcall mul32
05E2            276   ;        lcall hex2bcd
05E2            277   
05E2            278   ;        Send_BCD(bcd+1)
05E2            279            
05E2 C0E0       280            push acc
05E4 7401       280            mov a, #1
05E6 14         280            dec a
05E7 1201D4     280            lcall ?Set_Cursor_2 ; Select column and row
05EA D0E0       280            pop acc
05EC C000       281            push ar0
05EE A834       281            mov r0, minutes
05F0 1201DB     281            lcall ?Display_BCD
05F3 D000       281            pop ar0
05F5 C0E0       282            push acc
05F7 7404       282            mov a, #4
05F9 14         282            dec a
05FA 1201D4     282            lcall ?Set_Cursor_2 ; Select column and row
05FD D0E0       282            pop acc
05FF            283   ;        Send_BCD(bcd)
05FF C000       284            push ar0
0601 A833       284            mov r0, seconds
0603 1201DB     284            lcall ?Display_BCD
0606 D000       284            pop ar0
0608            285   ;        mov DPTR, #Hello_World
0608            286   ;        lcall SendString
0608            287   ;==============================================================================================
0608 F530       288            mov Count1ms+0, a
060A F531       289            mov Count1ms+1, a
060C            290            ; Increment the BCD counter
060C            291            
060C E573       292            mov a, MyHope
060E 2401       293            add a, #1
0610 F573       294            mov MyHope, a
0612            295   
0612            296            
0612 12081D     297            lcall ReadTemperature
0615 E533       298            mov a, Seconds
0617            299   ;        jb UPDOWN, Timer2_ISR_decrement
0617 2401       300            add a, #0x01
0619            301            ;sjmp Timer2_ISR_da
0619            302   ;Timer2_ISR_decrement:;=====================ISR DECREMENT=============================================
0619            303   ;        add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.    
0619            304            
0619            305            
0619            306   Timer2_ISR_da:
0619 D4         307            da a ; Decimal adjust instruction.  Check datasheet for more details!   
061A F533       308            mov seconds, a
061C            309   
061C B4600A     310            cjne a, #0x60, Timer2_ISR_done ;if seconds are not 60, go to ISR_done
061F 753300     311            mov Seconds, #0x0 ;reset seconds to 0
0622 E534       312            mov a, Minutes ; set a to previous minutes
0624 2401       313            add a, #0x01 ;add one to obtain current minutes
0626 D4         314            da a ;makes formatting nice 
0627 F534       315            mov Minutes, a ;put updated minutes into the counter
0629            316   ;        sjmp Timer2_ISR_M_aadjust
0629            317            
0629            318   Timer2_ISR_done:
0629 D0D0       319            pop psw
062B D0E0       320            pop acc
062D 32         321            reti
062E            322            
062E            323   
062E            324   MainProgram:;============================MAIN===========================================================
062E 75817F     325       mov sp, #0x7f
0631 120592     326            lcall Timer0_Init
0634 1205AC     327       lcall Timer2_Init
0637 120095     328       lcall Initialize_LEDs
063A 12007E     329       lcall Initialize_Serial_Port
063D 12009C     330       lcall Initialize_ADC
0640 120592     331       lcall Timer0_Init
0643 1205AC     332       lcall Timer2_Init
0646 120229     333       lcall INIT_SPI
0649            334     ;FSM Variables  ==================
0649 E4         335            clr a
064A F56B       336            mov temp_soak, a
064C 756B30     337       mov temp_soak, #0x30 ;TO BE CHANGED| Will remain in hex although
064F 756C3C     338            mov time_soak, #0x3c     ;HAS TO BE IN HEX only convert to bcd for display!
0652 756DDC     339            mov temp_refl, #220
0655 756E41     340            mov time_refl, #65
0658            341            
0658 756F19     342            mov temp, #25
065B 757000     343            mov timer, #0x00
065E 757100     344            mov state, #0x00
0661 757200     345            mov sec, #0x00
0664 753400     346            mov minutes, #0
0667 750100     347            mov mf, #0
066A 757300     348            mov MyHope, #0
066D            349   ;========================
066D            350     ;  lcall InitSerialPort
066D 759AFF     351            mov P0MOD, #11111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
0670            352       ; We use pins P1.0 and P1.1 as outputs also.  Configure accordingly.
0670 759BFF     353       mov P1MOD, #11111111b ; P1.0 and P1.0 are outputs
0673 120194     354       lcall ELCD_4BIT
0676            355     ;  clr EX1
0676 D2AF       356       setb EA
0678            357   
0678            358   ;        Set_Cursor(1,1)
0678            359   ;        Send_Constant_String(#MyString)
0678 B2EC       360            cpl LEDRA.4
067A D200       361            setb half_seconds_flag
067C 753350     362            mov Seconds, #0x50
067F            363   forever:;======================================================FOREVER===========================================================
067F E5E8       364            mov a, SWA ; read the channel to convert from the switches
0681 5407       365            anl a, #00000111B ; We need only the last three bits since there are only eight channels
0683 F5F0       366            mov b, a
0685 1200AC     367            lcall LTC2308_RW  ; Read the channel from the ADC
0688 120060     368            lcall hex2bcd16   ; Convert to bcd
068B            369   ;        lcall Display_BCD1 ; Display using the 7-segment displays
068B            370   ;        lcall SendNumber  ; Send to serial port
068B            371   ;        jnb BJTBase, pinpressed
068B 7AFA       372            mov R2, #250
068D            373            
068D 20F91C     374            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
0690 C002       375            push AR2
0692 7A32       375            mov R2, #50
0694 120145     375            lcall ?Wait_Milli_Seconds
0697 D002       375            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit_DE1SoC.inc'
0699 20F910     376            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
069C 30F9FD     377            jnb KEY.1, $    
069F C2CA       378            clr TR2 ; Stop timer 2
06A1 E4         379            clr a
06A2 F530       380            mov Count1ms+0, a
06A4 F531       381            mov Count1ms+1, a
06A6            382            ; Now clear the BCD counter
06A6 F532       383            mov BCD_counter, a
06A8 D2CA       384            setb TR2    ; Start timer 2
06AA 8003       385            sjmp loop_b ; Display the new value
06AC            386   loop_a:;======================================================FOREVER================================================
06AC 3000D0     387            jnb half_seconds_flag, forever
06AF            388   loop_b:;======================================================FOREVER================================================
06AF C200       389            clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
06B1 C0E0       390            push acc
06B3 740F       390            mov a, #15
06B5 14         390            dec a
06B6 1201D4     390            lcall ?Set_Cursor_2 ; Select column and row
06B9 D0E0       390            pop acc     ; the place in the LCD where we want the BCD counter value
06BB C000       391            push ar0
06BD A871       391            mov r0, state
06BF 1201DB     391            lcall ?Display_BCD
06C2 D000       391            pop ar0
06C4            392   ;        cpl LEDRA.4
06C4            393   
06C4 E571       394       mov a, state
06C6            395    ;=======================================================STATE 0========================================
06C6 B40079     396            cjne a, #select, RampToSoakState
06C9            397   ;Display Time Soak
06C9 C0E0       398            push acc
06CB 7401       398            mov a, #1
06CD 14         398            dec a
06CE 1201D6     398            lcall ?Set_Cursor_1 ; Select column and row
06D1 D0E0       398            pop acc
06D3 856C36     399            mov x+0, Time_Soak + 0
06D6 753700     400            mov x+1, #0
06D9 753800     401            mov x+2, #0
06DC 753900     402            mov x+3, #0
06DF 120252     403            lcall hex2bcd
06E2 C000       404            push ar0
06E4 A83F       404            mov r0, bcd+1
06E6 1201DB     404            lcall ?Display_BCD
06E9 D000       404            pop ar0
06EB C0E0       405            push acc
06ED 7403       405            mov a, #3
06EF 14         405            dec a
06F0 1201D6     405            lcall ?Set_Cursor_1 ; Select column and row
06F3 D0E0       405            pop acc
06F5 C000       406            push ar0
06F7 A83E       406            mov r0, bcd
06F9 1201DB     406            lcall ?Display_BCD
06FC D000       406            pop ar0
06FE            407   ;Display Temp Soak       
06FE C0E0       408            push acc
0700 7406       408            mov a, #6
0702 14         408            dec a
0703 1201D6     408            lcall ?Set_Cursor_1 ; Select column and row
0706 D0E0       408            pop acc
0708 856B36     409            mov x+0, Temp_Soak + 0
070B 753700     410            mov x+1, #0
070E 753800     411            mov x+2, #0
0711 753900     412            mov x+3, #0
0714 120252     413            lcall hex2bcd
0717 C000       414            push ar0
0719 A83F       414            mov r0, bcd+1
071B 1201DB     414            lcall ?Display_BCD
071E D000       414            pop ar0
0720 C0E0       415            push acc
0722 7408       415            mov a, #8
0724 14         415            dec a
0725 1201D6     415            lcall ?Set_Cursor_1 ; Select column and row
0728 D0E0       415            pop acc
072A C000       416            push ar0
072C A83E       416            mov r0, bcd
072E 1201DB     416            lcall ?Display_BCD
0731 D000       416            pop ar0
0733            417            
0733 30A148     418            jnb button1, nextstate
0736 30A278     419            jnb button2, TempSoakAdjust
0739 30A367     420            jnb button3, PathTimeSoakAdjust
073C 30A46A     421            jnb button4, PathTempReflowAdjust
073F 30A564     422            jnb button5, PathTimeReflowAdjust ; TimeReflowAdjust jump
0742            423            
0742            424            ;mov Seconds, #0x00
0742            425            ;mov minutes, #0
0742            426   RampToSoakState:         ;==============================STATE 1================================================
0742 B4012B     427            cjne a, #RampToSoak, PreHeatState
0745 753564     428            mov pwm, #100
0748 757200     429       mov sec, #0
074B            430        ;-----
074B            431       
074B            432     ;  lcall nextstate
074B            433    ;=============================Checking ih current temp has reaches soak temp==========================================   
074B 856536     434            mov x, hTemp
074E 753700     435            mov x+1, #0
0751 753800     436            mov x+2, #0
0754 753900     437            mov x+3, #0
0757            438   
0757 856B3A     439            mov y, temp_soak
075A 753B00     440            mov y+1, #0
075D 753C00     441            mov y+2, #0
0760 753D00     442            mov y+3, #0
0763 12035A     443            lcall x_lt_y
0766            444   ;====================================If its reached, move on to the next state, if not abort if 60 seconds passed=============
0766 300115     445            jnb     mf, nextstate
0769 E534       446            mov a, Minutes
076B            447   ;        cpl LEDRA.2
076B B4010D     448       cjne a, #0x01, SkipSetup
076E 802D       449       sjmp abort
0770            450   
0770            451   PreHeatState:;====================================================STATE 2===========================================
0770 B40208     452            cjne a, #PreHeat, RampToHeatState
0773 E573       453            mov a, MyHope
0775 B56C03     454            cjne a, Time_Soak, SkipSetup
0778 12077E     455            lcall nextstate
077B            456   RampToHeatState:
077B            457   SkipSetup:;=====================CHANGE  OF STATES==============================================
077B 02067F     458            ljmp forever
077E            459   nextstate: ;=====================CHANGE  OF STATES==============================================
077E C002       460            push AR2
0780 7A32       460            mov R2, #50
0782 120145     460            lcall ?Wait_Milli_Seconds
0785 D002       460            pop AR2
0787 753300     461            mov seconds, #0
078A 753400     462            mov minutes, #0
078D 757300     463            mov MyHope, #0
0790 E571       464            mov a, state
0792 2401       465            add a, #1
0794 B40615     466            cjne a, #6, NoStateReset
0797 757100     467            mov state, #0
079A            468   ;        cpl LEDRA.7
079A            469   
079A 02077B     470            ljmp SkipSetup
079D            471   abort: ;=================================ABORT1=====================================================
079D 757100     472            mov state, #0
07A0 02077B     473            ljmp SkipSetup
07A3            474   ;====================================================PATHS================================================
07A3            475   PathTimeSoakAdjust:
07A3 0207C7     476            ljmp TimeSoakAdjust
07A6            477   PathTimeReflowAdjust: 
07A6 0207F3     478            ljmp TimeReflowAdjust
07A9            479   PathTempReflowAdjust:
07A9 0207DD     480            ljmp TempReflowAdjust
07AC            481   NoStateReset:;=====================STATE OVERFLOW==============================================
07AC F571       482            mov state, a
07AE            483            ;cpl LEDRA.7
07AE 02077B     484            ljmp SkipSetup  
07B1            485   TempSoakAdjust:;=====================Soak Temperature adjustment==============================================
07B1 C002       486            push AR2
07B3 7A32       486            mov R2, #50
07B5 120145     486            lcall ?Wait_Milli_Seconds
07B8 D002       486            pop AR2;
07BA E56B       487            mov a, temp_soak
07BC 2401       488            add a, #0x01
07BE            489            ;cpl LEDRA.6
07BE B4AB4D     490            cjne a, #0xab, TempSoakNotOverflow ;0xab = 171
07C1 756B82     491            mov temp_soak, #0x82 ;0x82 = 130
07C4 02077B     492            ljmp SkipSetup
07C7            493   
07C7            494   TimeSoakAdjust:;=====================Soak time Adjustment==============================================
07C7 C002       495            push AR2
07C9 7A32       495            mov R2, #50
07CB 120145     495            lcall ?Wait_Milli_Seconds
07CE D002       495            pop AR2
07D0 E56C       496            mov a, Time_Soak
07D2 2401       497            add a, #0x01
07D4 B47932     498            cjne a, #0x79, TimeSoakNotOverflow;0x79=121
07D7 756C3C     499            mov time_soak, #0x3c ;0x3c=60
07DA 02077B     500            ljmp SkipSetup
07DD            501   TempReflowAdjust:;=====================Reflow Temp adjusment=============================================
07DD C002       502            push AR2
07DF 7A32       502            mov R2, #50
07E1 120145     502            lcall ?Wait_Milli_Seconds
07E4 D002       502            pop AR2
07E6 E56D       503            mov a, Temp_Refl
07E8 2401       504            add a, #0x01
07EA B4E626     505            cjne a, #0xe6, TempReflowNotOverflow ;0xe6 = 230 TBC POSSIBLY
07ED 756DD9     506            mov Temp_Refl, #0xd9 ;0xd9 = 217
07F0 02077B     507            ljmp SkipSetup
07F3            508   TimeReflowAdjust:;=====================Reflow TIME adjusment=============================================
07F3 C002       509            push AR2
07F5 7A32       509            mov R2, #50
07F7 120145     509            lcall ?Wait_Milli_Seconds
07FA D002       509            pop AR2
07FC E56E       510            mov a, Time_Refl
07FE 2401       511            add a, #0x01
0800 B44C15     512            cjne a, #0x4c, TimeReflowNotOverflow ; 0x4c=76
0803 756E2D     513            mov Time_Refl, #0x2d ;0x2d = 45
0806 02077B     514            ljmp SkipSetup
0809            515   TimeSoakNotOverflow:;=====================Soak time no overflow==============================================
0809 F56C       516            mov time_soak, a
080B 02077B     517            ljmp SkipSetup
080E            518   TempSoakNotOverflow:;=====================Soak Temperature no overflow==============================================
080E F56B       519            mov temp_soak, a
0810 02077B     520            ljmp SkipSetup
0813            521   TempReflowNotOverflow:
0813 F56D       522            mov temp_refl, a
0815 02077B     523            ljmp SkipSetup
0818            524   TimeReflowNotOverflow:;=====================Soak time no overflow==============================================
0818 F56E       525            mov time_Refl, a
081A 02077B     526            ljmp SkipSetup
081D            527   ReadTemperature: 
081D 75F000     528            mov b, #0
0820 1201F1     528            lcall _Read_ADC_Channel
0823 C000       529            push aR0
0825 A863       529            mov R0, cTemp
0827 1204C2     529            lcall _volt2ctemp
082A D000       529            pop aR0 
082C            530   ;        mov cTemp, bcd
082C 75F006     531            mov b, #6
082F 1201F1     531            lcall _Read_ADC_Channel
0832 C000       532            push aR0
0834 A865       532            mov R0, hTemp
0836 120509     532            lcall _volt2htemp
0839 D000       532            pop aR0
083B            533   ;        mov hTemp, bcd
083B 85633E     534            mov bcd+0, cTemp+0
083E 85643F     535            mov bcd+1, cTemp+1
0841 754000     536            mov bcd+2, #0
0844 754100     537            mov bcd+3, #0
0847 754200     538            mov bcd+4, #0
084A 1202DB     539            lcall bcd2hex
084D 853663     540            mov cTemp + 0, x + 0
0850 853764     541            mov cTemp + 1, x + 1
0853            542   ;======Adding cold junction temp=======================================================  
0853 E565       543            mov a, hTemp
0855 2563       544            add a, cTemp
0857 F565       545            mov hTemp, a
0859            546   ;======Since its in hex got to adjust to convert it to decimal=======================================================    
0859            547   ;        mov a, hTemp
0859            548    ;       da a
0859            549    ;       mov hTemp, a
0859            550    ;======Display=====================================================================================
0859            551   
0859            552            
0859 856536     553            mov x + 0, hTemp+ 0
085C 753700     554            mov x + 1, #0
085F 753800     555            mov x+2, #0
0862 753900     556            mov x+3, #0
0865 120252     557            lcall hex2bcd
0868 900565     558            mov DPTR, #Hello_World
086B 120247     559            lcall SendString
086E C000       560            push ar0
0870 A83F       560            mov r0, bcd+1
0872 120213     560            lcall ?Send_BCD
0875 D000       560            pop ar0
0877 C000       561            push ar0
0879 A83E       561            mov r0, bcd
087B 120213     561            lcall ?Send_BCD
087E D000       561            pop ar0
0880 C0E0       562            push acc
0882 7409       562            mov a, #9
0884 14         562            dec a
0885 1201D4     562            lcall ?Set_Cursor_2 ; Select column and row
0888 D0E0       562            pop acc
088A C000       563            push ar0
088C A83F       563            mov r0, bcd+1
088E 1201DB     563            lcall ?Display_BCD
0891 D000       563            pop ar0
0893 C0E0       564            push acc
0895 740B       564            mov a, #11
0897 14         564            dec a
0898 1201D4     564            lcall ?Set_Cursor_2 ; Select column and row
089B D0E0       564            pop acc
089D C000       565            push ar0
089F A83E       565            mov r0, bcd
08A1 1201DB     565            lcall ?Display_BCD
08A4 D000       565            pop ar0
08A6 900565     566            mov DPTR, #Hello_World
08A9 120247     567            lcall SendString
08AC            568            ;Send_BCD(bcd+1)
08AC            569            ;Send_BCD(bcd)
08AC 900565     570            mov DPTR, #Hello_World
08AF 120247     571            lcall SendString
08B2 22         572   ret
08B3            573   callnextstate: 
08B3 12077E     574            lcall nextstate
08B6            575   end
