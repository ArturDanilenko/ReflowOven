0000              1   ; This program tests the LTC2308 avaliable in the newer version of the DE1-SoC board.
0000              2   ; Access to the input pins of the ADC is avalible at connector J15. Here is the top
0000              3   ; view of the connector:
0000              4   ;
0000              5   ; +--+
0000              6   ; |  | <-- Red power button
0000              7   ; +--+
0000              8   ;
0000              9   ; +-----+-----+
0000             10   ; + GND | IN7 |
0000             11   ; +-----+-----+
0000             12   ; + IN6 | IN5 |
0000             13   ; +-----+-----+
0000             14   ; + IN4 | IN3 |
0000             15   ; +-----+-----+
0000             16   ; + IN2 | IN1 |
0000             17   ; ------+-----+
0000             18   ; + IN0 | 5V  |
0000             19   ; +-----+-----+
0000             20   ;      J15
0000             21   ; 
0000             22   ; Displays the result using the 7-segment displays and also sends it via the serial port to PUTTy.
0000             23   ;
0000             24   ; (c) Jesus Calvino-Fraga 2019
0000             25   ;
                 27   $LIST
0000             29   
0000             30   ; Bits used to access the LTC2308
0000             31   LTC2308_MISO bit 0xF8 ; Read only bit
0000             32   LTC2308_MOSI bit 0xF9 ; Write only bit
0000             33   LTC2308_SCLK bit 0xFA ; Write only bit
0000             34   LTC2308_ENN  bit 0xFB ; Write only bit
0000             35   
0000             36   ;BUTTONS
0000             37   button1          equ P2.1
0000             38   button2          equ P2.2
0000             39   button3          equ P2.3
0000             40   button4          equ P2.4
0000             41   button5          equ P2.5
0000             42   ;STATES
0000             43   Select           equ 0
0000             44   RAMPTOSOAK       equ 1
0000             45   PREHEAT          equ 2
0000             46   RAMPTOPEAK       equ 3
0000             47   REFLOW           equ 4
0000             48   COOLING          equ 5
0000             49   
0000             50   CLK EQU 33333333
0000             51   BAUD EQU 57600
0000             52   TIMER_2_RELOAD EQU (65536-(CLK/(32*BAUD)))
0000             53   TIMER_0_1ms EQU (65536-(CLK/(12*1000)))
0000             54   
0000             55   ;;
0000             56   ;;
0000             57   ;; PUSH BUTTON DEFINITIONS
0000             58   ;;
0000             59   ;;
0000             60   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             61   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is 12 unlike the AT89LP51RC2 where is 1.
0000             62   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             63   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             64   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0000             65   
0000             66   
0000             67   ; Reset vector
0000             68   org 0x0000
0000 020628      69       ljmp MainProgram
0003             70   
0003             71   ; External interrupt 0 vector (not used in this code)
0003             72   org 0x0003
0003 32          73            reti
0004             74   
0004             75   ; Timer/Counter 0 overflow interrupt vector
000B             76   org 0x000B
000B 0205A5      77            ljmp Timer0_ISR
000E             78   
000E             79   ; External interrupt 1 vector (not used in this code)
0013             80   org 0x0013
0013 32          81            reti
0014             82   
0014             83   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             84   org 0x001B
001B 32          85            reti
001C             86   
001C             87   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             88   org 0x0023 
0023 32          89            reti
0024             90            
0024             91   ; Timer/Counter 2 overflow interrupt vector
002B             92   org 0x002B
002B 0205C5      93            ljmp Timer2_ISR
002E             94            
002E             95   SOUND_OUT     equ P1.0
002E             96   UPDOWN        equ SWA.0
002E             97   
002E             98   ; Reset vector
002E             99   
002E            100   
002E            101   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            102   dseg at 0x30
0030            103   Count1ms:     ds 2 ; Used to determine when half second has passed
0032            104   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            105   Seconds:  ds 1
0034            106   Minutes: ds 1
0035            107   pwm: ds 1
0036            108   x:       ds 4
003A            109   y:       ds 4
003E            110   bcd:     ds 5
0043            111   buffer: ds 30
0061            112   vResult:         ds 2
0063            113   cTemp:   ds 2
0065            114   hTemp:   ds 3
0068            115   tTemp:   ds 3
006B            116   ;FSM Variables
006B            117   temp_soak: ds 1
006C            118   time_soak: ds 1
006D            119   temp_refl: ds 1
006E            120   time_refl: ds 1
006F            121   temp: ds 1
0070            122   timer: ds 1
0071            123   state: ds 1
0072            124   sec: ds 1
0073            125   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0073            126   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            127   bseg
0000            128   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            129   mf: dbit 1
0002            130   
002E            131   cseg     
002E            132   BJTBase equ P0.0
002E            133   ELCD_RS equ P1.2
002E            134   ELCD_RW equ P1.3
002E            135   ELCD_E  equ P1.4
002E            136   ELCD_D4 equ P1.5
002E            137   ELCD_D5 equ P1.6
002E            138   ELCD_D6 equ P1.7
002E            139   ELCD_D7 equ P0.6
002E            140   
002E            141   CE_ADC   EQU P0.2
002E            142   MY_MOSI EQU P0.0
002E            143   MY_MISO EQU P2.0
002E            144   MY_SCLK EQU P0.1
002E            145   
002E            146   PWMout equ P0.3
002E            147   
                622   $LIST
                150   $LIST
0541            152   
0541 0D0A4C54   153   InitialString: db '\r\nLTC2308 test program\r\n', 0
     43323330
     38207465
     73742070
     726F6772
     616D0D0A
     00
055A 48656C6F   154   MyString: db 'Helo213qwq', 0
     32313371
     777100
0565            155   Hello_World: ;indent to separate numbers in the putty
0565 0D0A00     156       DB  '\r','\n', 0
0568            157   
0568            158   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0568            159   T_7seg:
0568 40792430   160       DB 40H, 79H, 24H, 30H, 19H, 12H, 02H, 78H, 00H, 10H
     19120278
     0010
0572            161   
0572            162   ; Display the 4-digit bcd stored in [R3,R2] using the 7-segment displays
0572            163   
0572            164   
0572            165   ; Send a 4-digit BCD number stored in [R3,R2] to the serial port         
0572            166   
0572            167            
0572            168   ; Wait 1 millisecond using Timer 0
0572            169   Wait1ms:
0572 C28C       170            clr     TR0
0574 74F0       171            mov     a,#0xF0
0576 5589       172            anl     a,TMOD
0578 4401       173            orl     a,#0x01
057A F589       174            mov     TMOD,a
057C 758CF5     175            mov     TH0, #high(TIMER_0_1ms)
057F 758A27     176            mov     TL0, #low(TIMER_0_1ms)
0582 C28D       177            clr     TF0
0584 D28C       178            setb TR0
0586 308DFD     179            jnb     TF0,$
0589 C28C       180            clr     TR0
058B 22         181            ret
058C            182            
058C            183   ; Wait R2 milliseconds
058C            184   MyDelay:
058C 120572     185            lcall Wait1ms
058F DAFB       186       djnz R2, MyDelay
0591 22         187            ret
0592            188            
0592            189   Timer0_Init:
0592 E589       190            mov a, TMOD
0594 54F0       191            anl a, #0xf0 ; Clear the bits for timer 0
0596 4401       192            orl a, #0x01 ; Configure timer 0 as 16-timer
0598 F589       193            mov TMOD, a
059A 758CFD     194            mov TH0, #high(TIMER0_RELOAD)
059D 758A5A     195            mov TL0, #low(TIMER0_RELOAD)
05A0            196            ; Enable the timer and interrupts
05A0 D2A9       197       setb ET0  ; Enable timer 0 interrupt
05A2 D28C       198       setb TR0  ; Start timer 0
05A4 22         199            ret
05A5            200   
05A5            201   ;---------------------------------;
05A5            202   ; ISR for timer 0.  Set to execute;
05A5            203   ; every 1/4096Hz to generate a    ;
05A5            204   ; 2048 Hz square wave at pin P3.7 ;
05A5            205   ;---------------------------------;
05A5            206   Timer0_ISR:
05A5            207   ;        clr TF0  ; According to the data sheet this is done for us already.
05A5 758CFD     208            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
05A8 758A5A     209            mov TL0, #low(TIMER0_RELOAD)
05AB            210   ;        cpl SOUND_OUT ; Connect speaker to P3.7!
05AB 32         211            reti
05AC            212   
05AC            213   ;---------------------------------;
05AC            214   ; Routine to initialize the ISR   ;
05AC            215   ; for timer 2                     ;
05AC            216   ;---------------------------------;
05AC            217   Timer2_Init:
05AC 75C800     218            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
05AF 75CDF5     219            mov TH2, #high(TIMER2_RELOAD)
05B2 75CC27     220            mov TL2, #low(TIMER2_RELOAD)
05B5            221            ; Set the reload value
05B5 75CBF5     222            mov RCAP2H, #high(TIMER2_RELOAD)
05B8 75CA27     223            mov RCAP2L, #low(TIMER2_RELOAD)
05BB            224            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
05BB E4         225            clr a
05BC F530       226            mov Count1ms+0, a
05BE F531       227            mov Count1ms+1, a
05C0            228            ; Enable the timer and interrupts
05C0 D2AD       229       setb ET2  ; Enable timer 2 interrupt
05C2 D2CA       230       setb TR2  ; Enable timer 2
05C4 22         231            ret
05C5            232   
05C5            233   ;---------------------------------;
05C5            234   ; ISR for timer 2                 ;
05C5            235   ;---------------------------------;
05C5            236   Timer2_ISR:
05C5 C2CF       237            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
05C7            238   ;        cpl P1.1 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
05C7            239            
05C7            240            ; The two registers used in the ISR must be saved in the stack
05C7 C0E0       241            push acc
05C9 C0D0       242            push psw
05CB            243            
05CB            244            ; Increment the 16-bit one mili second counter
05CB 0530       245            inc Count1ms+0    ; Increment the low 8-bits first
05CD E530       246            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05CF 7002       247            jnz Inc_Done
05D1 0531       248            inc Count1ms+1
05D3            249   
05D3            250   Inc_Done:;===========================================ISR MAIN=============================================
05D3            251            ; Check if half second has passed
05D3 E530       252            mov a, Count1ms+0
05D5 B4F44B     253            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
05D8 E531       254            mov a, Count1ms+1
05DA B40146     255            cjne a, #high(500), Timer2_ISR_done
05DD            256            
05DD            257            ; 500 milliseconds have passed.  Set a flag so the main program knows
05DD D200       258            setb half_seconds_flag ; Let the main program know half second had passed
05DF            259            ; Toggle LEDR0 so it blinks
05DF            260            ;=====================Timer 0 controls============================================
05DF            261            ;cpl LEDRA.0
05DF B28C       262            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
05E1            263            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
05E1            264            ;==================================================================================================
05E1 E4         265            clr a
05E2            266            ;=====================Display=============================================
05E2            267   ;        mov x+0, Temp_soak+0
05E2            268   ;        mov x+1, #0
05E2            269   ;        mov x+2, #0
05E2            270   ;        mov x+3, #0
05E2            271   ;
05E2            272   ;        Load_Y(1)
05E2            273   ;        lcall mul32
05E2            274   ;        lcall hex2bcd
05E2            275   ;        Send_BCD(bcd+1)
05E2 C0E0       276            push acc
05E4 7401       276            mov a, #1
05E6 14         276            dec a
05E7 1201D4     276            lcall ?Set_Cursor_2 ; Select column and row
05EA D0E0       276            pop acc
05EC C000       277            push ar0
05EE A834       277            mov r0, minutes
05F0 1201DB     277            lcall ?Display_BCD
05F3 D000       277            pop ar0
05F5 C0E0       278            push acc
05F7 7404       278            mov a, #4
05F9 14         278            dec a
05FA 1201D4     278            lcall ?Set_Cursor_2 ; Select column and row
05FD D0E0       278            pop acc
05FF            279   ;        Send_BCD(bcd)
05FF C000       280            push ar0
0601 A833       280            mov r0, seconds
0603 1201DB     280            lcall ?Display_BCD
0606 D000       280            pop ar0
0608            281   ;        mov DPTR, #Hello_World
0608            282   ;        lcall SendString
0608            283   ;==============================================================================================
0608 F530       284            mov Count1ms+0, a
060A F531       285            mov Count1ms+1, a
060C            286            ; Increment the BCD counter
060C            287            
060C            288            
060C            289   
060C            290            
060C 120784     291            lcall ReadTemperature
060F E533       292            mov a, Seconds
0611            293   ;        jb UPDOWN, Timer2_ISR_decrement
0611 2401       294            add a, #0x01
0613            295            ;sjmp Timer2_ISR_da
0613            296   ;Timer2_ISR_decrement:;=====================ISR DECREMENT=============================================
0613            297   ;        add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.    
0613            298            
0613            299            
0613            300   Timer2_ISR_da:
0613 D4         301            da a ; Decimal adjust instruction.  Check datasheet for more details!   
0614 F533       302            mov seconds, a
0616            303   
0616 B4600A     304            cjne a, #0x60, Timer2_ISR_done ;if seconds are not 60, go to ISR_done
0619 753300     305            mov Seconds, #0x0 ;reset seconds to 0
061C E534       306            mov a, Minutes ; set a to previous minutes
061E 2401       307            add a, #0x01 ;add one to obtain current minutes
0620 D4         308            da a ;makes formatting nice 
0621 F534       309            mov Minutes, a ;put updated minutes into the counter
0623            310   ;        sjmp Timer2_ISR_M_aadjust
0623            311            
0623            312   Timer2_ISR_done:
0623 D0D0       313            pop psw
0625 D0E0       314            pop acc
0627 32         315            reti
0628            316            
0628            317   
0628            318   MainProgram:;============================MAIN===========================================================
0628 75817F     319       mov sp, #0x7f
062B 120592     320            lcall Timer0_Init
062E 1205AC     321       lcall Timer2_Init
0631 120095     322       lcall Initialize_LEDs
0634 12007E     323       lcall Initialize_Serial_Port
0637 12009C     324       lcall Initialize_ADC
063A 120592     325       lcall Timer0_Init
063D 1205AC     326       lcall Timer2_Init
0640 120229     327       lcall INIT_SPI
0643            328     ;FSM Variables  ==================
0643 E4         329            clr a
0644 F56B       330            mov temp_soak, a
0646 756B96     331       mov temp_soak, #150
0649 756C6E     332            mov time_soak, #110
064C 756DDC     333            mov temp_refl, #220
064F 756E41     334            mov time_refl, #65
0652            335            
0652 756F19     336            mov temp, #25
0655 757000     337            mov timer, #0x00
0658 757100     338            mov state, #0x00
065B 757200     339            mov sec, #0x00
065E 753400     340            mov minutes, #0
0661            341   ;========================
0661            342     ;  lcall InitSerialPort
0661 759AFF     343            mov P0MOD, #11111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
0664            344       ; We use pins P1.0 and P1.1 as outputs also.  Configure accordingly.
0664 759BFF     345       mov P1MOD, #11111111b ; P1.0 and P1.0 are outputs
0667 120194     346       lcall ELCD_4BIT
066A            347     ;  clr EX1
066A D2AF       348       setb EA
066C            349   
066C C0E0       350            push acc
066E 7401       350            mov a, #1
0670 14         350            dec a
0671 1201D6     350            lcall ?Set_Cursor_1 ; Select column and row
0674 D0E0       350            pop acc
0676 C083       351            push dph
0678 C082       351            push dpl
067A C0E0       351            push acc
067C 90055A     351            mov dptr, #MyString
067F 1201C9     351            lcall ?Send_Constant_String
0682 D0E0       351            pop acc
0684 D082       351            pop dpl
0686 D083       351            pop dph
0688 B2EC       352            cpl LEDRA.4
068A D200       353            setb half_seconds_flag
068C 753350     354            mov Seconds, #0x50
068F            355   forever:;======================================================FOREVER===========================================================
068F E5E8       356            mov a, SWA ; read the channel to convert from the switches
0691 5407       357            anl a, #00000111B ; We need only the last three bits since there are only eight channels
0693 F5F0       358            mov b, a
0695 1200AC     359            lcall LTC2308_RW  ; Read the channel from the ADC
0698 120060     360            lcall hex2bcd16   ; Convert to bcd
069B            361   ;        lcall Display_BCD1 ; Display using the 7-segment displays
069B            362   ;        lcall SendNumber  ; Send to serial port
069B            363   ;        jnb BJTBase, pinpressed
069B 7AFA       364            mov R2, #250
069D            365            
069D 20F91C     366            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
06A0 C002       367            push AR2
06A2 7A32       367            mov R2, #50
06A4 120145     367            lcall ?Wait_Milli_Seconds
06A7 D002       367            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit_DE1SoC.inc'
06A9 20F910     368            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
06AC 30F9FD     369            jnb KEY.1, $    
06AF C2CA       370            clr TR2 ; Stop timer 2
06B1 E4         371            clr a
06B2 F530       372            mov Count1ms+0, a
06B4 F531       373            mov Count1ms+1, a
06B6            374            ; Now clear the BCD counter
06B6 F532       375            mov BCD_counter, a
06B8 D2CA       376            setb TR2    ; Start timer 2
06BA 8003       377            sjmp loop_b ; Display the new value
06BC            378   loop_a:;======================================================FOREVER================================================
06BC 3000D0     379            jnb half_seconds_flag, forever
06BF            380   loop_b:;======================================================FOREVER================================================
06BF C200       381            clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
06C1            382   ;        Set_Cursor(1, 14)     ; the place in the LCD where we want the BCD counter value
06C1            383   ;        Display_BCD(Seconds)
06C1            384   ;        cpl LEDRA.4
06C1 E571       385       mov a, state
06C3 B40014     386            cjne a, #select, RampToSoakState
06C6 B2ED       387            cpl LEDRA.5
06C8 30A12D     388            jnb button1, nextstate
06CB 30A247     389            jnb button2, TempSoakAdjust
06CE 30A35D     390            jnb button3, TimeSoakAdjust
06D1 30A470     391            jnb button4, TempReflowAdjust
06D4 30A554     392            jnb button5, Path ; TimeReflowAdjust jump
06D7 753300     393            mov Seconds, #0x00
06DA            394   RampToSoakState:         
06DA B40118     395            cjne a, #RampToSoak, PreHeatState
06DD 753564     396            mov pwm, #100
06E0 757200     397       mov sec, #0
06E3 E533       398       mov a, Seconds
06E5 B46000     399       cjne a, #0x60, cont ;-----
06E8            400   ;        mov x, current_temp
06E8            401   ;        mov x+1, current_temp+1
06E8            402   ;        mov x+2, 0#
06E8            403   ;        mov x+3, #0
06E8            404   
06E8            405   ;        mov y, temp_soak
06E8            406   ;        mov y+1, temp_soak+1
06E8            407   ;        mov y+2, #0
06E8            408   ;        mov y+3, #0
06E8            409   ;        lcall x_lt_y
06E8            410   
06E8            411   ;        jnb     mf, cont            
06E8            412   ;        mov 
06E8            413      
06E8            414      
06E8            415   cont:
06E8            416   
06E8            417   
06E8            418   
06E8 E56B       419       mov a, temp_soak ;-----
06EA C3         420       clr c
06EB 956F       421       subb a, temp ;----
06ED 5003       422       jnc state1_done
06EF 757102     423       mov state, #2
06F2            424   state1_done:
06F2 02068F     425       ljmp forever
06F5            426   PreHeatState:
06F5            427            
06F5            428   SkipSetup:;=====================CHANGE  OF STATES==============================================
06F5 02068F     429            ljmp forever
06F8            430   nextstate: ;=====================CHANGE  OF STATES==============================================
06F8 C002       431            push AR2
06FA 7A32       431            mov R2, #50
06FC 120145     431            lcall ?Wait_Milli_Seconds
06FF D002       431            pop AR2
0701 E571       432            mov a, state
0703 2401       433            add a, #1
0705 B40608     434            cjne a, #6, NoStateReset
0708 757100     435            mov state, #0
070B B2EF       436            cpl LEDRA.7
070D 0206F5     437            ljmp SkipSetup
0710            438   NoStateReset:;=====================STATE OVERFLOW==============================================
0710 F571       439            mov state, a
0712            440            ;cpl LEDRA.7
0712 0206F5     441            ljmp SkipSetup  
0715            442   TempSoakAdjust:;=====================Soak Temperature adjustment==============================================
0715 C002       443            push AR2
0717 7A32       443            mov R2, #50
0719 120145     443            lcall ?Wait_Milli_Seconds
071C D002       443            pop AR2
071E E56B       444            mov a, temp_soak
0720 2401       445            add a, #1
0722            446            ;cpl LEDRA.6
0722 B4AB50     447            cjne a, #171, TempSoakNotOverflow
0725 756B82     448            mov temp_soak, #130
0728 0206F5     449            ljmp SkipSetup
072B            450   Path: 
072B 02075A     451            ljmp TimeReflowAdjust
072E            452   TimeSoakAdjust:;=====================Soak time Adjustment==============================================
072E C002       453            push AR2
0730 7A32       453            mov R2, #50
0732 120145     453            lcall ?Wait_Milli_Seconds
0735 D002       453            pop AR2
0737 E56C       454            mov a, Time_Soak
0739 2401       455            add a, #1
073B B47932     456            cjne a, #121, TimeSoakNotOverflow
073E 756C3C     457            mov time_soak, #60
0741 0206F5     458            ljmp SkipSetup
0744            459   TempReflowAdjust:;=====================Reflow Temp adjusment=============================================
0744 C002       460            push AR2
0746 7A32       460            mov R2, #50
0748 120145     460            lcall ?Wait_Milli_Seconds
074B D002       460            pop AR2
074D E56D       461            mov a, Temp_Refl
074F 2401       462            add a, #1
0751 B4E626     463            cjne a, #230, TempReflowNotOverflow
0754 756DD9     464            mov Temp_Refl, #217
0757 0206F5     465            ljmp SkipSetup
075A            466   TimeReflowAdjust:;=====================Reflow TIME adjusment=============================================
075A C002       467            push AR2
075C 7A32       467            mov R2, #50
075E 120145     467            lcall ?Wait_Milli_Seconds
0761 D002       467            pop AR2
0763 E56E       468            mov a, Time_Refl
0765 2401       469            add a, #1
0767 B44C15     470            cjne a, #76, TimeReflowNotOverflow
076A 756E2D     471            mov Time_Refl, #45
076D 0206F5     472            ljmp SkipSetup
0770            473   TimeSoakNotOverflow:;=====================Soak time no overflow==============================================
0770 F56C       474            mov time_soak, a
0772 0206F5     475            ljmp SkipSetup
0775            476   TempSoakNotOverflow:;=====================Soak Temperature no overflow==============================================
0775 F56B       477            mov temp_soak, a
0777 0206F5     478            ljmp SkipSetup
077A            479   TempReflowNotOverflow:
077A F56D       480            mov temp_refl, a
077C 0206F5     481            ljmp SkipSetup
077F            482   TimeReflowNotOverflow:;=====================Soak time no overflow==============================================
077F F56E       483            mov time_Refl, a
0781 0206F5     484            ljmp SkipSetup
0784            485   ReadTemperature: 
0784 75F000     486            mov b, #0
0787 1201F1     486            lcall _Read_ADC_Channel
078A C000       487            push aR0
078C A863       487            mov R0, cTemp
078E 1204C2     487            lcall _volt2ctemp
0791 D000       487            pop aR0 
0793            488   ;        mov cTemp, bcd
0793 75F006     489            mov b, #6
0796 1201F1     489            lcall _Read_ADC_Channel
0799 C000       490            push aR0
079B A865       490            mov R0, hTemp
079D 120509     490            lcall _volt2htemp
07A0 D000       490            pop aR0
07A2            491   ;        mov hTemp, bcd
07A2            492   ;======Adding cold junction temp=======================================================  
07A2 E565       493            mov a, hTemp
07A4 2563       494            add a, cTemp
07A6 F565       495            mov hTemp, a
07A8            496   ;======Since its in hex got to adjust to convert it to decimal=======================================================    
07A8 E565       497            mov a, hTemp
07AA D4         498            da a
07AB F565       499            mov hTemp, a
07AD            500    ;======Display=====================================================================================     
07AD C0E0       501            push acc
07AF 7409       501            mov a, #9
07B1 14         501            dec a
07B2 1201D4     501            lcall ?Set_Cursor_2 ; Select column and row
07B5 D0E0       501            pop acc
07B7 C000       502            push ar0
07B9 A866       502            mov r0, hTemp+1
07BB 1201DB     502            lcall ?Display_BCD
07BE D000       502            pop ar0
07C0 C0E0       503            push acc
07C2 740B       503            mov a, #11
07C4 14         503            dec a
07C5 1201D4     503            lcall ?Set_Cursor_2 ; Select column and row
07C8 D0E0       503            pop acc
07CA C000       504            push ar0
07CC A865       504            mov r0, hTemp
07CE 1201DB     504            lcall ?Display_BCD
07D1 D000       504            pop ar0
07D3            505   ;        Set_Cursor(2,5)
07D3            506   ;        Display_BCD(cTemp)
07D3 C000       507            push ar0
07D5 A864       507            mov r0, cTemp+1
07D7 120213     507            lcall ?Send_BCD
07DA D000       507            pop ar0
07DC C000       508            push ar0
07DE A863       508            mov r0, cTemp
07E0 120213     508            lcall ?Send_BCD
07E3 D000       508            pop ar0
07E5 900565     509            mov DPTR, #Hello_World
07E8 120247     510            lcall SendString
07EB C000       511            push ar0
07ED A866       511            mov r0, hTemp+1
07EF 120213     511            lcall ?Send_BCD
07F2 D000       511            pop ar0
07F4 C000       512            push ar0
07F6 A865       512            mov r0, hTemp
07F8 120213     512            lcall ?Send_BCD
07FB D000       512            pop ar0
07FD 900565     513            mov DPTR, #Hello_World
0800 120247     514            lcall SendString
0803 C000       515            push ar0
0805 A83F       515            mov r0, bcd+1
0807 120213     515            lcall ?Send_BCD
080A D000       515            pop ar0
080C C000       516            push ar0
080E A83E       516            mov r0, bcd
0810 120213     516            lcall ?Send_BCD
0813 D000       516            pop ar0
0815 900565     517            mov DPTR, #Hello_World
0818 120247     518            lcall SendString
081B 22         519   ret
081C            520   callnextstate: 
081C 1206F8     521            lcall nextstate
081F            522   end
