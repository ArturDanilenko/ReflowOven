0000              1   ; This program tests the LTC2308 avaliable in the newer version of the DE1-SoC board.
0000              2   ; Access to the input pins of the ADC is avalible at connector J15. Here is the top
0000              3   ; view of the connector:
0000              4   ;
0000              5   ; +--+
0000              6   ; |  | <-- Red power button
0000              7   ; +--+
0000              8   ;
0000              9   ; +-----+-----+
0000             10   ; + GND | IN7 |
0000             11   ; +-----+-----+H
0000             12   ; + IN6 | IN5 |
0000             13   ; +-----+-----+
0000             14   ; + IN4 | IN3 |
0000             15   ; +-----+-----+
0000             16   ; + IN2 | IN1 |
0000             17   ; ------+-----+
0000             18   ; + IN0 | 5V  |
0000             19   ; +-----+-----+
0000             20   ;      J15
0000             21   ; 
0000             22   ; Displays the result using the 7-segment displays and also sends it via the serial port to PUTTy.
0000             23   ;
0000             24   ; (c) Jesus Calvino-Fraga 2019
0000             25   ;
                 27   $LIST
0000             29   
0000             30   ; Bits used to access the LTC2308
0000             31   LTC2308_MISO bit 0xF8 ; Read only bit
0000             32   LTC2308_MOSI bit 0xF9 ; Write only bit
0000             33   LTC2308_SCLK bit 0xFA ; Write only bit
0000             34   LTC2308_ENN  bit 0xFB ; Write only bit
0000             35   
0000             36   ;BUTTONS
0000             37   button1          equ P2.1
0000             38   button2          equ P2.2
0000             39   button3          equ P2.3
0000             40   button4          equ P2.4
0000             41   button5          equ P2.5
0000             42   
0000             43   FAN equ P0.4
0000             44   ;STATES
0000             45   Select           equ 0
0000             46   RAMPTOSOAK       equ 1
0000             47   PREHEAT          equ 2
0000             48   RAMPTOPEAK       equ 3
0000             49   REFLOW           equ 4
0000             50   COOLING          equ 5
0000             51   PARAM equ 4
0000             52   
0000             53   CLK EQU 33333333
0000             54   BAUD EQU 57600
0000             55   TIMER_2_RELOAD EQU (65536-(CLK/(32*BAUD)))
0000             56   TIMER_0_1ms EQU (65536-(CLK/(12*1000)))
0000             57   
0000             58   ;;
0000             59   ;;
0000             60   ;; PUSH BUTTON DEFINITIONS
0000             61   ;;
0000             62   ;;
0000             63   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             64   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is 12 unlike the AT89LP51RC2 where is 1.
0000             65   TIMER0_RELOADXL EQU (5*TIMER0_RELOAD)
0000             66   TIMER2_RATE   EQU 1000    ; 1000Hz, for a timer tick of 1ms
0000             67   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             68   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0000             69   
0000             70   
0000             71   ; Reset vector
0000             72   org 0x0000
0000 02071C      73       ljmp MainProgram
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 0205F4      81            ljmp Timer0_ISR
000E             82   
000E             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             88   org 0x001B
001B 32          89            reti
001C             90   
001C             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023 
0023 32          93            reti
0024             94            
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 020618      97            ljmp Timer2_ISR
002E             98            
002E             99   SOUNDOUT     equ P1.0
002E            100   UPDOWN        equ SWA.0
002E            101   
002E            102   ; Reset vector
002E            103   
002E            104   
002E            105   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            106   dseg at 0x30
0030            107   Count1ms:     ds 2 ; Used to determine when half second has passed
0032            108   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            109   Seconds:  ds 1
0034            110   Minutes: ds 1
0035            111   pwm: ds 1
0036            112   x:       ds 4
003A            113   y:       ds 4
003E            114   bcd:     ds 5
0043            115   buffer: ds 30
0061            116   vResult:         ds 2
0063            117   cTemp:   ds 2
0065            118   hTemp:   ds 3
0068            119   tTemp:   ds 3
006B            120   realTemp: ds 3
006E            121   ;FSM Variables
006E            122   temp_soak: ds 1
006F            123   time_soak: ds 1
0070            124   temp_refl: ds 1
0071            125   time_refl: ds 1
0072            126   temp: ds 1
0073            127   timer: ds 1
0074            128   state: ds 1
0075            129   sec: ds 1
0076            130   Aseconds: ds 1
0077            131   WorkingTime: ds 1
0078            132   Temperature: ds 1
0079            133   SpeakerTimer: ds 1
007A            134   shortbeepflag: ds 1
007B            135   longbeepflag: ds 1
007C            136   actuallylongbeepflag: ds 1
007D            137   counter: ds 1
007E            138   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
007E            139   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            140   bseg
0000            141   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            142   PwmFlag: dbit 1
0002            143   mf: dbit 1
0003            144   
0003            145   ;longbeepflag: dbit 1
0003            146   
002E            147   cseg     
002E            148   BJTBase equ P0.0
002E            149   ELCD_RS equ P1.2
002E            150   ELCD_RW equ P1.3
002E            151   ELCD_E  equ P1.4
002E            152   ELCD_D4 equ P1.5
002E            153   ELCD_D5 equ P1.6
002E            154   ELCD_D6 equ P1.7
002E            155   ELCD_D7 equ P0.6
002E            156   
002E            157   CE_ADC   EQU P0.2
002E            158   MY_MOSI EQU P0.0
002E            159   MY_MISO EQU P2.0
002E            160   MY_SCLK EQU P0.1
002E            161   
002E            162   PWMout equ P0.3
002E            163   
                643   $LIST
                166   $LIST
056E            168   
056E 0D0A4C54   169   InitialString: db '\r\nLTC2308 test program\r\n', 0
     43323330
     38207465
     73742070
     726F6772
     616D0D0A
     00
0587 48656C6F   170   MyString: db 'Helo213qwq', 0
     32313371
     777100
0592            171   Hello_World: ;indent to separate numbers in the putty
0592 0D0A00     172       DB  '\r','\n', 0
0595            173   helpfulspace:
0595 2000       174            DB ' ', 0 
0597            175   
0597            176   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0597            177   T_7seg:
0597 40792430   178       DB 40H, 79H, 24H, 30H, 19H, 12H, 02H, 78H, 00H, 10H
     19120278
     0010
05A1            179       
05A1            180   ; Displays a BCD number in HEX1-HEX0
05A1            181   Display_BCD_7_Seg:
05A1            182            
05A1 900597     183            mov dptr, #T_7seg
05A4            184            
05A4            185   ;        mov x, realTemp
05A4            186   ;        mov x+1, realTemp+1
05A4            187   ;        mov x+2, #0
05A4            188   ;        mov x+3, #0
05A4            189            
05A4            190   ;        lcall hex2bcd
05A4            191   ;        mov realTemp+1, bcd + 1
05A4            192   ;        mov realTemp, bcd
05A4            193            
05A4 E56C       194            mov a, realTemp+1
05A6 540F       195            anl a, #0FH
05A8 93         196            movc a, @a+dptr
05A9 F58F       197            mov HEX5, a
05AB            198   
05AB E56B       199            mov a, realTemp
05AD C4         200            swap a
05AE 540F       201            anl a, #0FH
05B0 93         202            movc a, @a+dptr
05B1 F58E       203            mov HEX4, a
05B3            204            
05B3 E56B       205            mov a, realTemp
05B5 540F       206            anl a, #0FH
05B7 93         207            movc a, @a+dptr
05B8 F594       208            mov HEX3, a
05BA            209            
05BA 75921C     210            mov HEX1, #0b0011100
05BD 759146     211            mov HEX0, #0b1000110
05C0            212            
05C0 22         213            ret
05C1            214   
05C1            215   ; Display the 4-digit bcd stored in [R3,R2] using the 7-segment displays
05C1            216   
05C1            217   
05C1            218   ; Send a 4-digit BCD number stored in [R3,R2] to the serial port         
05C1            219   
05C1            220            
05C1            221   ; Wait 1 millisecond using Timer 0
05C1            222   Wait1ms:
05C1 C28C       223            clr     TR0
05C3 74F0       224            mov     a,#0xF0
05C5 5589       225            anl     a,TMOD
05C7 4401       226            orl     a,#0x01
05C9 F589       227            mov     TMOD,a
05CB 758CF5     228            mov     TH0, #high(TIMER_0_1ms)
05CE 758A27     229            mov     TL0, #low(TIMER_0_1ms)
05D1 C28D       230            clr     TF0
05D3 D28C       231            setb TR0
05D5 308DFD     232            jnb     TF0,$
05D8 C28C       233            clr     TR0
05DA 22         234            ret
05DB            235            
05DB            236   ; Wait R2 milliseconds
05DB            237   MyDelay:
05DB 1205C1     238            lcall Wait1ms
05DE DAFB       239       djnz R2, MyDelay
05E0 22         240            ret
05E1            241            
05E1            242   Timer0_Init:
05E1 E589       243            mov a, TMOD
05E3 54F0       244            anl a, #0xf0 ; Clear the bits for timer 0
05E5 4401       245            orl a, #0x01 ; Configure timer 0 as 16-timer
05E7 F589       246            mov TMOD, a
05E9 758CFD     247            mov TH0, #high(TIMER0_RELOAD)
05EC 758A5A     248            mov TL0, #low(TIMER0_RELOAD)
05EF            249            ; Enable the timer and interrupts
05EF D2A9       250       setb ET0  ; Enable timer 0 interrupt
05F1 D28C       251       setb TR0  ; Start timer 0
05F3 22         252            ret
05F4            253   
05F4            254   ;---------------------------------;
05F4            255   ; ISR for timer 0.  Set to execute;
05F4            256   ; every 1/4096Hz to generate a    ;
05F4            257   ; 2048 Hz square wave at pin P3.7 ;
05F4            258   ;---------------------------------;
05F4            259   Timer0_ISR:
05F4            260   ;        clr TF0  ; According to the data sheet this is done for us already.
05F4            261   
05F4 758CFD     262            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
05F7 758A5A     263            mov TL0, #low(TIMER0_RELOAD) 
05FA            264   ;        mov a, actuallylongbeepflag
05FA            265   ;        add a, #1
05FA            266   ;        cjne a, #2, LoadLongTimeReload
05FA B290       267            cpl SoundOut
05FC            268   ;        mov actuallylongbeepflag, a
05FC            269   ;        reti
05FC            270   ;LoadLongTimeReload:
05FC            271            
05FC 32         272            reti
05FD            273   
05FD            274   ;---------------------------------;
05FD            275   ; Routine to initialize the ISR   ;
05FD            276   ; for timer 2                     ;
05FD            277   ;---------------------------------;
05FD            278   
05FD            279   Timer2_Init:
05FD 75C800     280            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0600 75CDF5     281            mov TH2, #high(TIMER2_RELOAD)
0603 75CC27     282            mov TL2, #low(TIMER2_RELOAD)
0606            283            ; Set the reload value
0606 75CBF5     284            mov RCAP2H, #high(TIMER2_RELOAD)
0609 75CA27     285            mov RCAP2L, #low(TIMER2_RELOAD)
060C B2E9       286            cpl LEDRA.1
060E            287            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
060E E4         288            clr a
060F F530       289            mov Count1ms+0, a
0611 F531       290            mov Count1ms+1, a
0613            291            ; Enable the timer and interrupts
0613 D2AD       292       setb ET2  ; Enable timer 2 interrupt
0615 D2CA       293       setb TR2  ; Enable timer 2
0617            294   
0617 22         295            ret
0618            296   
0618            297   ;---------------------------------;
0618            298   ; ISR for timer 2                 ;
0618            299   ;---------------------------------;
0618            300   Timer2_ISR:
0618 C2CF       301            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
061A            302   ;        cpl P1.1 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
061A            303            
061A            304            ; The two registers used in the ISR must be saved in the stack
061A C0E0       305            push acc
061C C0D0       306            push psw
061E            307            
061E            308            ; Increment the 16-bit one mili second counter
061E 0530       309            inc Count1ms+0    ; Increment the low 8-bits first
0620 E530       310            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0622            311   
0622 7002       312            jnz Inc_Done
0624 0531       313            inc Count1ms+1
0626            314   
0626            315   Inc_Done:;===========================================ISR MAIN=============================================
0626            316            ; Check if half second has passed
0626 E530       317            mov a, Count1ms+0
0628 B4FA2B     318            cjne a, #low(250), ISR_done ; Warning: this instruction changes the carry flag!
062B E531       319            mov a, Count1ms+1
062D B40026     320            cjne a, #high(250), ISR_done
0630            321            
0630            322            ; 500 milliseconds have passed.  Set a flag so the main program knows
0630 D200       323            setb half_seconds_flag ; Let the main program know half second had passed
0632            324            ; Toggle LEDR0 so it blinks
0632            325            ;=====================Timer 0 controls============================================
0632            326            ;cpl LEDRA.0
0632 E574       327            mov a, state
0634 B40002     328            cjne a, #0, DoPwm
0637 8003       329            sjmp DontDo
0639            330   DoPwm:
0639 120C03     331            lcall pwmmodule
063C            332   DontDo:
063C C0E0       333            push acc
063E 740F       333            mov a, #15
0640 14         333            dec a
0641 1201D4     333            lcall ?Set_Cursor_2 ; Select column and row
0644 D0E0       333            pop acc     ; the place in the LCD where we want the BCD counter value
0646 C000       334            push ar0
0648 A874       334            mov r0, state
064A 1201DB     334            lcall ?Display_BCD
064D D000       334            pop ar0
064F            335            ;Display_BCD(speakertimer)
064F E57A       336            mov a, shortbeepflag
0651 B40005     337            cjne a, #0, Beep
0654            338   ;        mov a, actuallylongbeepflag
0654            339   ;        cjne a, #0, Beep
0654            340   ;        clr TR0
0654 803E       341            sjmp skiptheskip
0656            342   ISR_done:
0656 020717     343            ljmp Timer2_ISR_done
0659            344   Beep:
0659 D28C       345            setb TR0
065B            346            ;clr soundout
065B            347   ;        cpl LEDRA.6
065B E579       348            mov a, SpeakerTimer
065D 2401       349            add a, #0x01
065F B4020A     350            cjne a, #0x02, KeepGoing
0662 E4         351            clr a
0663 F579       352            mov SpeakerTimer, a
0665 757A00     353            mov shortbeepflag, #0
0668 C28C       354            clr TR0
066A            355            ;setb soundout
066A            356   ;                cpl LEDRA.0
066A 8006       357            sjmp skiptheskip1
066C            358   KeepGoing: 
066C F579       359            mov SpeakerTimer, a
066E 8056       360            sjmp skipbeep
0670            361   ;        clr TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0670            362            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0670 B2EB       363   cpl LEDRA.3
0672            364   skiptheskip1:
0672 E57B       365            mov a, longbeepflag
0674 B40004     366            cjne a, #0, LongBeep1
0677 C28C       367            clr TR0
0679 8019       368            sjmp skiptheskip
067B            369   LongBeep1:
067B D28C       370            setb TR0
067D            371   ;        clr soundout
067D E579       372            mov a, SpeakerTimer
067F 2401       373            add a, #0x01
0681 B4060A     374            cjne a, #0x06, KeepGoing1
0684 E4         375            clr a
0685 F579       376            mov SpeakerTimer, a
0687 757B00     377            mov longbeepflag, #0
068A C28C       378            clr TR0
068C            379   ;        setb soundout
068C            380   ;        cpl LEDRA.2
068C 8006       381            sjmp skiptheskip
068E            382            ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%where tf do we jump
068E            383   KeepGoing1: 
068E F579       384            mov SpeakerTimer, a
0690 D28C       385            setb TR0
0692 8032       386            sjmp skipbeep
0694            387   skiptheskip:     
0694 E57C       388            mov a, actuallylongbeepflag
0696 B2E9       389            cpl LEDRA.1
0698 B40004     390            cjne a, #0, LongBeep2
069B C28C       391            clr TR0
069D 8027       392            sjmp skipbeep
069F            393   LongBeep2:
069F D28C       394            setb TR0
06A1            395   ;        clr soundout
06A1 E579       396            mov a, SpeakerTimer
06A3 2401       397            add a, #0x01
06A5 B40102     398            cjne a, #0x01, KeepOff
06A8 C28C       399            clr TR0
06AA            400   KeepOff:
06AA B40615     401            cjne a, #0x06, KeepGoing2
06AD E4         402            clr a
06AE F579       403            mov SpeakerTimer, a
06B0 E57D       404            mov a, counter
06B2 2401       405            add a, #1
06B4 B40605     406            cjne a, #6, sigmabaulz
06B7 757C00     407            mov actuallylongbeepflag, #0
06BA D28C       408            setb TR0
06BC            409   sigmabaulz: 
06BC E57D       410            mov a, counter
06BE C28C       411            clr TR0
06C0            412   ;        setb soundout
06C0 B2EA       413            cpl LEDRA.2
06C2            414            ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%where tf do we jump
06C2            415   KeepGoing2: 
06C2 B2EE       416            cpl LEDRA.6
06C4 F579       417            mov SpeakerTimer, a
06C6            418   ;        setb TR0
06C6            419   
06C6            420   ;        setb soundout
06C6            421            
06C6            422   skipbeep:
06C6            423            
06C6            424   ;        sjmp skipbeep
06C6            425   skipmorebeeps:
06C6 E4         426            clr a
06C7            427            ;=====================Display=============================================
06C7 857636     428            mov x+0, Aseconds+0
06CA 753700     429            mov x+1, #0
06CD 753800     430            mov x+2, #0
06D0 753900     431            mov x+3, #0
06D3            432   ;
06D3            433   ;        Load_Y(1)
06D3            434   ;        lcall mul32
06D3 120251     435            lcall hex2bcd
06D6            436   ;        Send_BCD(bcd+1)
06D6            437            
06D6 C0E0       438            push acc
06D8 7401       438            mov a, #1
06DA 14         438            dec a
06DB 1201D4     438            lcall ?Set_Cursor_2 ; Select column and row
06DE D0E0       438            pop acc
06E0 C000       439            push ar0
06E2 A83F       439            mov r0, bcd+1
06E4 1201DB     439            lcall ?Display_BCD
06E7 D000       439            pop ar0
06E9 C0E0       440            push acc
06EB 7404       440            mov a, #4
06ED 14         440            dec a
06EE 1201D4     440            lcall ?Set_Cursor_2 ; Select column and row
06F1 D0E0       440            pop acc
06F3            441   ;        Send_BCD(bcd)
06F3 C000       442            push ar0
06F5 A83E       442            mov r0, bcd
06F7 1201DB     442            lcall ?Display_BCD
06FA D000       442            pop ar0
06FC            443   ;        mov DPTR, #Hello_World
06FC            444   ;        lcall SendString
06FC            445   ;==============================================================================================
06FC F530       446            mov Count1ms+0, a
06FE F531       447            mov Count1ms+1, a
0700            448            ; Increment the BCD counter
0700            449            
0700            450   ;        mov a, MyHope
0700            451   ;        add a, #1
0700            452   ;        mov MyHope, a
0700            453            
0700 12091B     454            lcall ReadTemperature
0703            455   ;        mov a, Seconds
0703            456   ;        jb UPDOWN, Timer2_ISR_decrement
0703            457   ;        add a, #0x01
0703            458            
0703            459            
0703            460            
0703            461   Timer2_ISR_da:
0703 E533       462            mov a, seconds
0705 2401       463            add a, #1
0707 B4040B     464            cjne a, #PARAM, NoTReset
070A 753300     465            mov seconds, #0
070D E576       466            mov a, Aseconds
070F 2401       467            add a, #1
0711 F576       468            mov Aseconds, a
0713 8002       469            sjmp skipresethere
0715            470   NoTReset:
0715 F533       471            mov seconds, a
0717            472   skipresethere:
0717            473            
0717            474   Timer2_ISR_done:
0717 D0D0       475            pop psw
0719 D0E0       476            pop acc
071B 32         477            reti
071C            478            
071C            479   
071C            480   MainProgram:;============================MAIN===========================================================
071C 75817F     481       mov sp, #0x7f
071F 1205E1     482       lcall Timer0_Init
0722 1205FD     483       lcall Timer2_Init
0725 120095     484       lcall Initialize_LEDs
0728 12007E     485       lcall Initialize_Serial_Port
072B 12009C     486       lcall Initialize_ADC
072E 1205E1     487       lcall Timer0_Init
0731 1205FD     488       lcall Timer2_Init
0734 120228     489       lcall INIT_SPI
0737 D284       490       setb Fan
0739 C28C       491       clr TR0
073B            492   ;FSM Variables  ==================
073B E4         493            clr a
073C F56E       494            mov temp_soak, a
073E 756E82     495       mov temp_soak, #0x82 ; Will remain in hex, 0x82 is orig value else is for debugging
0741 756F3C     496            mov time_soak, #0x3c     ;HAS TO BE IN HEX only convert to bcd for display!
0744 7570DC     497            mov temp_refl, #0xdc ;230 0xdc is original, else debug
0747 757114     498            mov time_refl, #0x14 ;65
074A            499            
074A 757219     500            mov temp, #25
074D 757300     501            mov timer, #0x00
0750 757400     502            mov state, #0x00
0753 757501     503            mov sec, #0x01
0756 753400     504            mov minutes, #0
0759 750200     505            mov mf, #0
075C 757600     506            mov Aseconds, #0
075F 757700     507            mov WorkingTime, #0x00
0762 757A00     508            mov shortbeepflag, #0
0765 757B00     509            mov longbeepflag, #0
0768 757C00     510            mov actuallylongbeepflag, #0
076B 757900     511            mov speakertimer, #0
076E 757D00     512            mov counter, #0
0771            513   ;========================
0771            514     ;  lcall InitSerialPort
0771            515            ;clr TR0
0771 759AFF     516       mov P0MOD, #11111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
0774            517       ; We use pins P1.0 and P1.1 as outputs also.  Configure accordingly.
0774 759BFF     518       mov P1MOD, #11111111b ; P1.0 and P1.0 are outputs
0777 120194     519       lcall ELCD_4BIT
077A            520     ;  clr EX1
077A D2AF       521       setb EA
077C            522   
077C            523   ;        Set_Cursor(1,1)F
077C            524   ;        Send_Constant_String(#MyString)
077C B2EC       525            cpl LEDRA.4
077E D200       526            setb half_seconds_flag
0780 753350     527            mov Seconds, #0x50
0783 1209B4     528            lcall DisplayVariables
0786            529   ;        cpl TR0
0786            530   forever:;======================================================FOREVER===========================================================
0786 20FB2D     531            jb KEY.3, startnormal
0789 C002       532            push AR2
078B 7A32       532            mov R2, #50
078D 120145     532            lcall ?Wait_Milli_Seconds
0790 D002       532            pop AR2
0792 20FB21     533            jb KEY.3, startnormal
0795            534            
0795 757700     535            mov WorkingTime, #0x00
0798 757A00     536            mov shortbeepflag, #0
079B 757B00     537            mov longbeepflag, #0
079E 757C00     538            mov actuallylongbeepflag, #0
07A1 757900     539            mov speakertimer, #0
07A4 757400     540            mov state, #0x00
07A7 757501     541            mov sec, #0x01
07AA 750200     542            mov mf, #0
07AD 757600     543            mov Aseconds, #0
07B0 C283       544            clr pwmout
07B2 C2CA       545            clr TR2
07B4 C28C       546            clr TR0
07B6            547            
07B6            548   startnormal:     
07B6 E5E8       549            mov a, SWA ; read the channel to convert from the switches
07B8 5407       550            anl a, #00000111B ; We need only the last three bits since there are only eight channels
07BA F5F0       551            mov b, a
07BC 1200AC     552            lcall LTC2308_RW  ; Read the channel from the ADC
07BF 120060     553            lcall hex2bcd16   ; Convert to bcd
07C2            554   ;        lcall Display_BCD1 ; Display using the 7-segment displays
07C2            555   ;        lcall SendNumber  ; Send to serial port
07C2            556   ;        jnb BJTBase, pinpressed
07C2 7AFA       557            mov R2, #250
07C4            558            
07C4 20F91C     559            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
07C7 C002       560            push AR2
07C9 7A32       560            mov R2, #50
07CB 120145     560            lcall ?Wait_Milli_Seconds
07CE D002       560            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit_DE1SoC.inc'
07D0 20F910     561            jb KEY.1, loop_a  ; if the KEY1 button is not pressed skip
07D3 30F9FD     562            jnb KEY.1, $    
07D6 C2CA       563            clr TR2 ; Stop timer 2
07D8 E4         564            clr a
07D9 F530       565            mov Count1ms+0, a
07DB F531       566            mov Count1ms+1, a
07DD            567            ; Now clear the BCD counter
07DD F532       568            mov BCD_counter, a
07DF D2CA       569            setb TR2    ; Start timer 2
07E1 8003       570            sjmp loop_b ; Display the new value
07E3            571   loop_a:;======================================================FOREVER================================================
07E3 3000A0     572            jnb half_seconds_flag, forever
07E6            573   loop_b:;======================================================FOREVER================================================
07E6 C200       574            clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
07E8            575   ;        Set_Cursor(2, 15)     ; the place in the LCD where we want the BCD counter value
07E8            576            ;Display_BCD(state)
07E8            577   ;        Display_BCD(sec)
07E8            578   ;        cpl LEDRA.4
07E8            579   
07E8 E574       580       mov a, state
07EA            581    ;=======================================================STATE 0========================================
07EA            582   ResetState:
07EA B40031     583            cjne a, #select, RampToSoakState
07ED            584   ;Display Time Soak
07ED 753400     585            mov minutes, #0                                 ;set timer to zero until state 1 is active
07F0 753300     586            mov seconds, #0
07F3 30A122     587            jnb button1, Pathnextstate
07F6 30A20B     588            jnb button2, PathTempSoakAdjust
07F9 30A30D     589            jnb button3, PathTimeSoakAdjust
07FC 30A414     590            jnb button4, PathTempReflowAdjust
07FF 30A50C     591            jnb button5, PathTimeReflowAdjust ; TimeReflowAdjust jump
0802            592   
0802 801A       593            sjmp RampToSoakState
0804            594   PathTempSoakAdjust:
0804 120A5B     595            lcall TempSoakAdjust
0807 8012       596            sjmp SkipSetup1
0809            597   PathTimeSoakAdjust:
0809 120ACA     598            lcall TimeSoakAdjust
080C 800D       599            sjmp SkipSetup1
080E            600   PathTimeReflowAdjust: 
080E 120BBA     601            lcall TimeReflowAdjust
0811 8008       602            sjmp SkipSetup1
0813            603   PathTempReflowAdjust:
0813 120B4B     604            lcall TempReflowAdjust
0816 8003       605            sjmp SkipSetup1
0818            606   PathNextState:
0818 0208E4     607            ljmp nextstate
081B            608   SkipSetup1:;=====================CHANGE  OF STATES==============================================
081B 020786     609            ljmp forever
081E            610   
081E            611            ;mov Seconds, #0x00
081E            612            ;mov minutes, #0
081E            613   RampToSoakState:         ;==============================STATE 1================================================
081E B4013A     614            cjne a, #RampToSoak, PreHeatState
0821 757728     615            mov WorkingTime, #0x28
0824            616            
0824            617     ;  mov sec, #0
0824            618    ;=============================Checking ih current temp has reaches soak temp==========================================   
0824 856B36     619            mov x, RealTemp
0827 753700     620            mov x+1, #0
082A 753800     621            mov x+2, #0
082D 753900     622            mov x+3, #0
0830            623   
0830 E56E       624            mov a, temp_soak
0832 940A       625            subb a, #0x0a
0834 F578       626            mov temperature, a
0836 E574       627            mov a, state
0838 85783A     628            mov y, temperature
083B 753B00     629            mov y+1, #0
083E 753C00     630            mov y+2, #0
0841 753D00     631            mov y+3, #0
0844 120359     632            lcall x_lt_y
0847            633   ;====================================If its reached, move on to the next state, if not abort if 60 seconds passed=============
0847 300271     634            jnb     mf, nextstatepath
084A            635            
084A E576       636            mov a, Aseconds
084C B43CCC     637       cjne a, #0x3c, SkipSetup1
084F 753A3C     638       mov y, #0x3c
0852 120359     639            lcall x_lt_y
0855 3002C3     640            jnb mf, skipsetup1
0858            641            
0858 020900     642       ljmp abort
085B            643   
085B            644   PreHeatState:;====================================================STATE 2===========================================
085B B4020B     645            cjne a, #PreHeat, RampToHeatState
085E 757704     646            mov WorkingTime, #0x04
0861 E576       647            mov a, Aseconds
0863 B56F7B     648            cjne a, Time_Soak, SkipSetup
0866 1208E4     649            lcall nextstate
0869            650   RampToHeatState:;====================================================STATE 3===========================================
0869 B40323     651            cjne a, #RampToPeak, ReflowState
086C 757728     652            mov WorkingTime, #0x28
086F 856B36     653            mov x, RealTemp
0872 753700     654            mov x+1, #0
0875 753800     655            mov x+2, #0
0878 753900     656            mov x+3, #0
087B            657            
087B 85703A     658            mov y, temp_refl
087E 753B00     659            mov y+1, #0
0881 753C00     660            mov y+2, #0
0884 753D00     661            mov y+3, #0
0887 120359     662            lcall x_lt_y
088A            663                            
088A 300257     664            jnb     mf, nextstate
088D 8052       665            sjmp SkipSetup
088F            666   ReflowState:
088F B4042B     667            cjne a, #Reflow, CoolingState
0892            668   
0892 757704     669            mov WorkingTime, #0x04
0895            670            
0895            671            ;subb a, #0x0a
0895            672            ;       mov a, Aseconds
0895            673      ; cjne a, #0x3c, nextstate
0895 856B3A     674       mov y, RealTemp
0898 753B00     675       mov y + 1, #0
089B 753C00     676       mov y + 2, #0
089E 753D00     677       mov y + 3, #0
08A1            678       
08A1 753AEB     679            mov y+0, #low (0xeb % 0x10000) 
08A4 753B00     679            mov y+1, #high(0xeb % 0x10000) 
08A7 753C00     679            mov y+2, #low (0xeb / 0x10000) 
08AA 753D00     679            mov y+3, #high(0xeb / 0x10000) 
08AD 120359     680            lcall x_lt_y
08B0 300231     681            jnb mf, nextstate
08B3            682            
08B3            683      ; ljmp abort
08B3 E576       684            mov a, Aseconds
08B5 B57129     685            cjne a, Time_Refl, SkipSetup
08B8 1208E4     686            lcall nextstate
08BB            687   nextstatepath:
08BB 8027       688            sjmp nextstate
08BD            689   CoolingState:
08BD B40521     690            cjne a, #Cooling, SkipSetup
08C0 757700     691            mov WorkingTime, #0x00
08C3 856B36     692            mov x, RealTemp
08C6 753700     693            mov x+1, #0
08C9 753800     694            mov x+2, #0
08CC 753900     695            mov x+3, #0
08CF            696   
08CF 753A3C     697            mov y, #0x3c
08D2 753B00     698            mov y+1, #0
08D5 753C00     699            mov y+2, #0
08D8 753D00     700            mov y+3, #0
08DB 120359     701            lcall x_lt_y
08DE            702                            
08DE 200203     703            jb      mf, nextstate
08E1            704            
08E1            705   SkipSetup:;=====================CHANGE  OF STATES==============================================
08E1            706            
08E1 020786     707            ljmp forever
08E4            708   nextstate: ;=====================CHANGE  OF STATES==============================================
08E4 C002       709            push AR2
08E6 7A32       709            mov R2, #50
08E8 120145     709            lcall ?Wait_Milli_Seconds
08EB D002       709            pop AR2
08ED 753300     710            mov seconds, #0
08F0 757600     711            mov Aseconds, #0
08F3 E574       712            mov a, state
08F5 2401       713            add a, #1
08F7 B40614     714            cjne a, #6, NoStateReset
08FA            715   ;        lcall longbeep
08FA 757400     716            mov state, #0
08FD            717            
08FD            718   
08FD 0208E1     719            ljmp SkipSetup
0900            720   abort: ;=================================ABORT1=====================================================
0900 757400     721            mov state, #0
0903 757700     722            mov WorkingTime, #0x00
0906 757600     723            mov Aseconds, #0
0909 C283       724            clr Pwmout
090B 0208E1     725            ljmp SkipSetup
090E            726   ;====================================================PATHS==(if ljmp is outside of bounds)==============================================
090E            727   
090E            728   NoStateReset:;=====================STATE OVERFLOW==============================================
090E F574       729            mov state, a
0910            730            ;cpl LEDRA.7
0910 B40502     731            cjne a, #5, SWAG4DAYZ
0913            732   ;        lcall actuallylongbeep
0913            733   ;        lcall shortbeep
0913            734            ;
0913 8003       735            sjmp skipswag
0915            736   SWAG4DAYZ:
0915            737   ;        lcall shortbeep
0915            738   ;        lcall longbeep
0915 120C4F     739            lcall actuallylongbeep
0918            740   skipswag:        
0918 0208E1     741            ljmp SkipSetup  
091B            742   
091B            743   ReadTemperature: 
091B 75F000     744            mov b, #0
091E 1201F1     744            lcall _Read_ADC_Channel
0921 C000       745            push aR0
0923 A863       745            mov R0, cTemp
0925 1204C1     745            lcall _volt2ctemp
0928 D000       745            pop aR0 
092A            746   ;        mov cTemp, #25
092A 75F003     747            mov b, #3
092D 1201F1     747            lcall _Read_ADC_Channel
0930 C000       748            push aR0
0932 A865       748            mov R0, hTemp
0934 120508     748            lcall _volt2htemp
0937 D000       748            pop aR0
0939            749    
0939 12054C     750            lcall addTemps
093C            751    ;======Display PUTTY=====================================================================================
093C            752   
093C            753   
093C            754            ; this is a new line
093C            755   ;        mov DPTR, #Hello_World
093C            756   ;        lcall SendString
093C            757   
093C            758            
093C            759            ; ============send oven temp to putty===============
093C C000       760            push ar0
093E A86C       760            mov r0, realTemp+1
0940 120212     760            lcall ?Send_BCD
0943 D000       760            pop ar0
0945 C000       761            push ar0
0947 A86B       761            mov r0, realTemp
0949 120212     761            lcall ?Send_BCD
094C D000       761            pop ar0
094E 900595     762            mov DPTR, #helpfulspace
0951 120246     763            lcall SendString
0954 857436     764            mov x, state
0957 120251     765            lcall Hex2bcd
095A 853E74     766            mov state, bcd
095D C000       767            push ar0
095F A874       767            mov r0, state
0961 120212     767            lcall ?Send_BCD
0964 D000       767            pop ar0         
0966            768   ;        Send_BCD(bcd+1)
0966            769   ;        Send_BCD(bcd)
0966            770            ; ==================display oven temp on LCD==============
0966 C0E0       771            push acc
0968 7409       771            mov a, #9
096A 14         771            dec a
096B 1201D4     771            lcall ?Set_Cursor_2 ; Select column and row
096E D0E0       771            pop acc
0970 C000       772            push ar0
0972 A86C       772            mov r0, realTemp+1
0974 1201DB     772            lcall ?Display_BCD
0977 D000       772            pop ar0
0979 C0E0       773            push acc
097B 740B       773            mov a, #11
097D 14         773            dec a
097E 1201D4     773            lcall ?Set_Cursor_2 ; Select column and row
0981 D0E0       773            pop acc
0983 C000       774            push ar0
0985 A86B       774            mov r0, realTemp
0987 1201DB     774            lcall ?Display_BCD
098A D000       774            pop ar0
098C            775   ;        Set_Cursor(2, 9)
098C            776   ;        Display_BCD(bcd+1)
098C            777   ;        Set_Cursor(2, 11)
098C            778   ;        Display_BCD(bcd)
098C 900592     779            mov DPTR, #Hello_World
098F 120246     780            lcall SendString
0992 1205A1     781            lcall Display_BCD_7_Seg
0995            782            
0995            783            ; ================== send "hot temp" to putty===========
0995 900592     784            mov DPTR, #Hello_World
0998 120246     785            lcall SendString
099B            786   ;        Send_BCD(cTemp+1)
099B            787   ;        Send_BCD(cTemp)
099B            788            
099B            789                    
099B 856B3E     790            mov bcd + 0, RealTemp + 0
099E 856C3F     791            mov bcd + 1, RealTemp + 1
09A1 754000     792            mov bcd+2, #0
09A4 754100     793            mov bcd+3, #0
09A7 754200     794            mov bcd+4, #0
09AA 1202DA     795            lcall bcd2hex
09AD 85366B     796            mov RealTemp+0, x+0
09B0 85376C     797            mov RealTemp+1,x+1
09B3 22         798   ret
09B4            799       
09B4            800   DisplayVariables:
09B4 C0E0       801            push acc
09B6 7405       801            mov a, #5
09B8 14         801            dec a
09B9 1201D6     801            lcall ?Set_Cursor_1 ; Select column and row
09BC D0E0       801            pop acc
09BE 856F36     802            mov x+0, Time_Soak + 0
09C1 753700     803            mov x+1, #0
09C4 753800     804            mov x+2, #0
09C7 753900     805            mov x+3, #0
09CA 120251     806            lcall hex2bcd
09CD C000       807            push ar0
09CF A83F       807            mov r0, bcd+1
09D1 1201DB     807            lcall ?Display_BCD
09D4 D000       807            pop ar0
09D6 C0E0       808            push acc
09D8 7407       808            mov a, #7
09DA 14         808            dec a
09DB 1201D6     808            lcall ?Set_Cursor_1 ; Select column and row
09DE D0E0       808            pop acc
09E0 C000       809            push ar0
09E2 A83E       809            mov r0, bcd
09E4 1201DB     809            lcall ?Display_BCD
09E7 D000       809            pop ar0
09E9            810   ;Display Temp Soak       
09E9 C0E0       811            push acc
09EB 7400       811            mov a, #0
09ED 14         811            dec a
09EE 1201D6     811            lcall ?Set_Cursor_1 ; Select column and row
09F1 D0E0       811            pop acc
09F3 856E36     812            mov x+0, Temp_Soak + 0
09F6 120251     813            lcall hex2bcd
09F9 C000       814            push ar0
09FB A83F       814            mov r0, bcd+1
09FD 1201DB     814            lcall ?Display_BCD
0A00 D000       814            pop ar0
0A02 C0E0       815            push acc
0A04 7402       815            mov a, #2
0A06 14         815            dec a
0A07 1201D6     815            lcall ?Set_Cursor_1 ; Select column and row
0A0A D0E0       815            pop acc
0A0C C000       816            push ar0
0A0E A83E       816            mov r0, bcd
0A10 1201DB     816            lcall ?Display_BCD
0A13 D000       816            pop ar0
0A15            817   ;display time Reflow
0A15 857136     818            mov x+0, Time_Refl + 0
0A18 120251     819            lcall hex2bcd
0A1B C0E0       820            push acc
0A1D 740F       820            mov a, #15
0A1F 14         820            dec a
0A20 1201D6     820            lcall ?Set_Cursor_1 ; Select column and row
0A23 D0E0       820            pop acc
0A25 C000       821            push ar0
0A27 A83E       821            mov r0, bcd
0A29 1201DB     821            lcall ?Display_BCD
0A2C D000       821            pop ar0
0A2E            822   ;display temp reflow
0A2E C0E0       823            push acc
0A30 740A       823            mov a, #10
0A32 14         823            dec a
0A33 1201D6     823            lcall ?Set_Cursor_1 ; Select column and row
0A36 D0E0       823            pop acc
0A38 857036     824            mov x+0, Temp_Refl + 0
0A3B 120251     825            lcall hex2bcd
0A3E C000       826            push ar0
0A40 A83F       826            mov r0, bcd+1
0A42 1201DB     826            lcall ?Display_BCD
0A45 D000       826            pop ar0
0A47 C0E0       827            push acc
0A49 740C       827            mov a, #12
0A4B 14         827            dec a
0A4C 1201D6     827            lcall ?Set_Cursor_1 ; Select column and row
0A4F D0E0       827            pop acc
0A51 C000       828            push ar0
0A53 A83E       828            mov r0, bcd
0A55 1201DB     828            lcall ?Display_BCD
0A58 D000       828            pop ar0
0A5A 22         829            ret
0A5B            830            
0A5B            831   TempSoakAdjust:;=====================Soak Temperature adjustment==============================================
0A5B C002       832            push AR2
0A5D 7A32       832            mov R2, #50
0A5F 120145     832            lcall ?Wait_Milli_Seconds
0A62 D002       832            pop AR2;
0A64 E56E       833            mov a, temp_soak
0A66 2401       834            add a, #0x01
0A68            835            ;cpl LEDRA.6
0A68 B4AB30     836            cjne a, #0xab, TempSoakNotOverflow ;0xab = 171
0A6B 756E82     837            mov temp_soak, #0x82 ;0x82 = 130
0A6E C0E0       838            push acc
0A70 7400       838            mov a, #0
0A72 14         838            dec a
0A73 1201D6     838            lcall ?Set_Cursor_1 ; Select column and row
0A76 D0E0       838            pop acc
0A78 856E36     839            mov x+0, Temp_Soak + 0
0A7B 120251     840            lcall hex2bcd
0A7E C000       841            push ar0
0A80 A83F       841            mov r0, bcd+1
0A82 1201DB     841            lcall ?Display_BCD
0A85 D000       841            pop ar0
0A87 C0E0       842            push acc
0A89 7402       842            mov a, #2
0A8B 14         842            dec a
0A8C 1201D6     842            lcall ?Set_Cursor_1 ; Select column and row
0A8F D0E0       842            pop acc
0A91 C000       843            push ar0
0A93 A83E       843            mov r0, bcd
0A95 1201DB     843            lcall ?Display_BCD
0A98 D000       843            pop ar0
0A9A 22         844            ret
0A9B            845            ;ljmp SkipSetup
0A9B            846   TempSoakNotOverflow:;=====================Soak Temperature no overflow==============================================
0A9B F56E       847            mov temp_soak, a
0A9D C0E0       848            push acc
0A9F 7400       848            mov a, #0
0AA1 14         848            dec a
0AA2 1201D6     848            lcall ?Set_Cursor_1 ; Select column and row
0AA5 D0E0       848            pop acc
0AA7 856E36     849            mov x+0, Temp_Soak + 0
0AAA 120251     850            lcall hex2bcd
0AAD C000       851            push ar0
0AAF A83F       851            mov r0, bcd+1
0AB1 1201DB     851            lcall ?Display_BCD
0AB4 D000       851            pop ar0
0AB6 C0E0       852            push acc
0AB8 7402       852            mov a, #2
0ABA 14         852            dec a
0ABB 1201D6     852            lcall ?Set_Cursor_1 ; Select column and row
0ABE D0E0       852            pop acc
0AC0 C000       853            push ar0
0AC2 A83E       853            mov r0, bcd
0AC4 1201DB     853            lcall ?Display_BCD
0AC7 D000       853            pop ar0
0AC9 22         854       ret
0ACA            855   TimeSoakAdjust:;=====================Soak time Adjustment==============================================
0ACA C002       856            push AR2
0ACC 7A32       856            mov R2, #50
0ACE 120145     856            lcall ?Wait_Milli_Seconds
0AD1 D002       856            pop AR2
0AD3 E56F       857            mov a, Time_Soak
0AD5 2401       858            add a, #0x01
0AD7 B47939     859            cjne a, #0x79, TimeSoakNotOverflow;0x79=121
0ADA 756F3C     860            mov time_soak, #0x3c ;0x3c=60
0ADD C0E0       861            push acc
0ADF 7405       861            mov a, #5
0AE1 14         861            dec a
0AE2 1201D6     861            lcall ?Set_Cursor_1 ; Select column and row
0AE5 D0E0       861            pop acc
0AE7 856F36     862            mov x+0, Time_Soak + 0
0AEA 753700     863            mov x+1, #0
0AED 753800     864            mov x+2, #0
0AF0 753900     865            mov x+3, #0
0AF3 120251     866            lcall hex2bcd
0AF6 C000       867            push ar0
0AF8 A83F       867            mov r0, bcd+1
0AFA 1201DB     867            lcall ?Display_BCD
0AFD D000       867            pop ar0
0AFF C0E0       868            push acc
0B01 7407       868            mov a, #7
0B03 14         868            dec a
0B04 1201D6     868            lcall ?Set_Cursor_1 ; Select column and row
0B07 D0E0       868            pop acc
0B09 C000       869            push ar0
0B0B A83E       869            mov r0, bcd
0B0D 1201DB     869            lcall ?Display_BCD
0B10 D000       869            pop ar0
0B12 22         870            ret
0B13            871   TimeSoakNotOverflow:;=====================Soak time no overflow==============================================
0B13 F56F       872            mov time_soak, a
0B15 C0E0       873            push acc
0B17 7405       873            mov a, #5
0B19 14         873            dec a
0B1A 1201D6     873            lcall ?Set_Cursor_1 ; Select column and row
0B1D D0E0       873            pop acc
0B1F 856F36     874            mov x+0, Time_Soak + 0
0B22 753700     875            mov x+1, #0
0B25 753800     876            mov x+2, #0
0B28 753900     877            mov x+3, #0
0B2B 120251     878            lcall hex2bcd
0B2E C000       879            push ar0
0B30 A83F       879            mov r0, bcd+1
0B32 1201DB     879            lcall ?Display_BCD
0B35 D000       879            pop ar0
0B37 C0E0       880            push acc
0B39 7407       880            mov a, #7
0B3B 14         880            dec a
0B3C 1201D6     880            lcall ?Set_Cursor_1 ; Select column and row
0B3F D0E0       880            pop acc
0B41 C000       881            push ar0
0B43 A83E       881            mov r0, bcd
0B45 1201DB     881            lcall ?Display_BCD
0B48 D000       881            pop ar0
0B4A 22         882            ret
0B4B            883   TempReflowAdjust:;=====================Reflow Temp adjusment=============================================
0B4B C002       884            push AR2
0B4D 7A32       884            mov R2, #50
0B4F 120145     884            lcall ?Wait_Milli_Seconds
0B52 D002       884            pop AR2
0B54 E570       885            mov a, Temp_Refl
0B56 2401       886            add a, #0x01
0B58 B4E630     887            cjne a, #0xe6, TempReflowNotOverflow ;0xe6 = 230 TBC POSSIBLY
0B5B 7570D9     888            mov Temp_Refl, #0xd9 ;0xd9 = 217
0B5E C0E0       889            push acc
0B60 740A       889            mov a, #10
0B62 14         889            dec a
0B63 1201D6     889            lcall ?Set_Cursor_1 ; Select column and row
0B66 D0E0       889            pop acc
0B68 857036     890            mov x+0, Temp_Refl + 0
0B6B 120251     891            lcall hex2bcd
0B6E C000       892            push ar0
0B70 A83F       892            mov r0, bcd+1
0B72 1201DB     892            lcall ?Display_BCD
0B75 D000       892            pop ar0
0B77 C0E0       893            push acc
0B79 740C       893            mov a, #12
0B7B 14         893            dec a
0B7C 1201D6     893            lcall ?Set_Cursor_1 ; Select column and row
0B7F D0E0       893            pop acc
0B81 C000       894            push ar0
0B83 A83E       894            mov r0, bcd
0B85 1201DB     894            lcall ?Display_BCD
0B88 D000       894            pop ar0
0B8A 22         895            ret
0B8B            896   TempReflowNotOverflow:
0B8B F570       897            mov temp_refl, a
0B8D C0E0       898            push acc
0B8F 740A       898            mov a, #10
0B91 14         898            dec a
0B92 1201D6     898            lcall ?Set_Cursor_1 ; Select column and row
0B95 D0E0       898            pop acc
0B97 857036     899            mov x+0, Temp_Refl + 0
0B9A 120251     900            lcall hex2bcd
0B9D C000       901            push ar0
0B9F A83F       901            mov r0, bcd+1
0BA1 1201DB     901            lcall ?Display_BCD
0BA4 D000       901            pop ar0
0BA6 C0E0       902            push acc
0BA8 740C       902            mov a, #12
0BAA 14         902            dec a
0BAB 1201D6     902            lcall ?Set_Cursor_1 ; Select column and row
0BAE D0E0       902            pop acc
0BB0 C000       903            push ar0
0BB2 A83E       903            mov r0, bcd
0BB4 1201DB     903            lcall ?Display_BCD
0BB7 D000       903            pop ar0
0BB9 22         904            ret
0BBA            905   TimeReflowAdjust:;=====================Reflow TIME adjusment=============================================
0BBA C002       906            push AR2
0BBC 7A32       906            mov R2, #50
0BBE 120145     906            lcall ?Wait_Milli_Seconds
0BC1 D002       906            pop AR2
0BC3 E571       907            mov a, Time_Refl
0BC5 2401       908            add a, #0x01
0BC7 B42E1D     909            cjne a, #0x2e, TimeReflowNotOverflow ; 0x4c=76
0BCA 757114     910            mov Time_Refl, #0x14 ;0x2d = 45
0BCD 857136     911            mov x+0, Time_Refl + 0
0BD0 120251     912            lcall hex2bcd
0BD3 C0E0       913            push acc
0BD5 740F       913            mov a, #15
0BD7 14         913            dec a
0BD8 1201D6     913            lcall ?Set_Cursor_1 ; Select column and row
0BDB D0E0       913            pop acc
0BDD C000       914            push ar0
0BDF A83E       914            mov r0, bcd
0BE1 1201DB     914            lcall ?Display_BCD
0BE4 D000       914            pop ar0
0BE6 22         915            ret
0BE7            916   TimeReflowNotOverflow:;=====================Soak time no overflow==============================================
0BE7 F571       917            mov time_Refl, a
0BE9 857136     918            mov x+0, Time_Refl + 0
0BEC 120251     919            lcall hex2bcd
0BEF C0E0       920            push acc
0BF1 740F       920            mov a, #15
0BF3 14         920            dec a
0BF4 1201D6     920            lcall ?Set_Cursor_1 ; Select column and row
0BF7 D0E0       920            pop acc
0BF9 C000       921            push ar0
0BFB A83E       921            mov r0, bcd
0BFD 1201DB     921            lcall ?Display_BCD
0C00 D000       921            pop ar0
0C02 22         922            ret
0C03            923   
0C03            924   
0C03            925   PWMmodule:
0C03 E575       926            mov a, sec
0C05            927   ;        
0C05 B42839     928            cjne a, #40, DontReset
0C08 757500     929            mov sec, #0
0C0B            930   BackUp:  
0C0B            931   ;        mov a, sec
0C0B 857536     932            mov x, sec
0C0E 753700     933            mov x+1, #0
0C11 753800     934            mov x+2, #0
0C14 753900     935            mov x+3, #0
0C17            936   
0C17 85773A     937            mov y, WorkingTime
0C1A 753B00     938            mov y+1, #0
0C1D 753C00     939            mov y+2, #0
0C20 753D00     940            mov y+3, #0
0C23 1203C1     941            lcall x_lteq_y
0C26            942   ;====================================If its reached, move on to the next state, if not abort if 60 seconds passed=============
0C26 200205     943            jb      mf, SetPwmFlagOn
0C29 E4         944            clr a
0C2A F501       945            mov PWMFlag, a
0C2C            946            
0C2C            947   ;        cpl SOUND_OUT ; Connect speaker to P3.7!
0C2C 8002       948            sjmp Power
0C2E            949   SetPwmFlagOn:
0C2E            950   
0C2E D201       951            setb PWMFlag
0C30            952   Power:   
0C30 E575       953            mov a, sec
0C32 2401       954            add a, #1
0C34 F575       955            mov sec, a
0C36            956   ;        cpl LEDRA.3
0C36 E501       957            mov a, PWMFlag
0C38 B40003     958            cjne a, #0, TurnITON
0C3B C283       959            clr PWMout
0C3D            960            
0C3D 22         961            ret
0C3E            962            
0C3E            963   TurnItOn:
0C3E D283       964            setb PWMout
0C40 22         965            ret
0C41            966            
0C41            967   DontReset:
0C41 F575       968            mov sec, a
0C43 80C6       969            sjmp BackUp
0C45            970   shortbeep:
0C45 757A01     971            mov ShortBeepFlag, #1
0C48 B2ED       972            cpl LEDRA.5
0C4A 22         973            ret
0C4B            974   longbeep:
0C4B 757B01     975            mov LongBeepFlag, #1
0C4E 22         976            ret     
0C4F            977   actuallylongbeep:
0C4F 757C01     978            mov actuallylongbeepflag, #1
0C52 22         979            ret
0C53            980   en
